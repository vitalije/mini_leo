<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="vitalije.20180822151714.2"><vh>Start</vh>
<v t="vitalije.20180822200821.1"><vh>to clean</vh></v>
<v t="vitalije.20180822175121.1"><vh>@edit mkdocs.yml</vh></v>
<v t="vitalije.20180822175420.1"><vh>@edit .gitignore</vh></v>
<v t="vitalije.20180822184227.1"><vh>@edit .travis.yml</vh></v>
<v t="vitalije.20180822184624.1"><vh>@edit MANIFEST.in</vh></v>
<v t="vitalije.20180823001012.1"><vh>@clean rust-installer.sh</vh></v>
<v t="vitalije.20180823103429.1"><vh>@edit setup.cfg</vh></v>
<v t="vitalije.20180823104438.1"><vh>@edit SConstruct</vh></v>
<v t="vitalije.20180823104449.1"><vh>@edit pyproject.toml</vh></v>
<v t="vitalije.20180823132035.1"><vh>@edit requirements_dev.txt</vh></v>
<v t="vitalije.20180822185454.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580500000069636f6e7371035d71047d7105285804000000747970657106580400000066696c657107680758610000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f6175746f322e706e677108580700000072656c506174687109581900000066696c655f69636f6e732f66696c655f6175746f322e706e67710a58050000007768657265710b580e0000006265666f7265486561646c696e65710c5807000000796f6666736574710d4b005807000000786f6666736574710e4b02580400000078706164710f4b0158020000006f6e71105805000000766e6f64657111580a00000076697375616c49636f6e71125801000000317113756173732e"><vh>@auto tox.ini</vh></v>
<v t="vitalije.20180822173307.1"><vh>@settings</vh>
<v t="vitalije.20191229164032.1"><vh>@data extract-patterns</vh></v>
<v t="vitalije.20180822171822.1"><vh>@button n-save @key=Ctrl-s</vh>
<v t="vitalije.20180822171822.2"><vh>hl</vh></v>
<v t="vitalije.20180822171822.3"><vh>mdlines</vh></v>
<v t="vitalije.20180822171822.4"><vh>getf</vh></v>
<v t="vitalije.20180822171822.5"><vh>putf</vh></v>
<v t="vitalije.20180822171822.6"><vh>obradi</vh></v>
</v>
</v>
</v>
<v t="vitalije.20180822200124.1"><vh>@clean mini_leo/__init__.py</vh></v>
<v t="vitalije.20180822200508.1"><vh>@clean mini_leo/cli.py</vh>
<v t="vitalije.20180822200550.2"><vh>main (cli.py)</vh></v>
</v>
<v t="vitalije.20180822200526.1"><vh>@clean mini_leo/mini_leo.py</vh></v>
<v t="vitalije.20190622133345.1"><vh>@clean tests/test_mini_leo.py</vh></v>
<v t="vitalije.20180822183813.1"><vh>@clean setup.py</vh>
<v t="vitalije.20191230142308.1"><vh>build_native</vh></v>
</v>
<v t="vitalije.20191231151920.1"><vh>@clean build_wheel.py</vh>
<v t="vitalije.20191231152226.1"><vh>cargo_build</vh></v>
<v t="vitalije.20191231152252.1"><vh>METADATA</vh></v>
<v t="vitalije.20191231152300.1"><vh>WHEEL</vh></v>
<v t="vitalije.20191231153206.1"><vh>getversion</vh></v>
<v t="vitalije.20191231155959.1"><vh>make_wheel</vh></v>
<v t="vitalije.20191231160001.1"><vh>makelinux_wheel</vh></v>
<v t="vitalije.20191231160004.1"><vh>makewin_wheel</vh></v>
<v t="vitalije.20191231160008.1"><vh>makeany_wheel</vh></v>
</v>
<v t="vitalije.20191231162159.1"><vh>@clean appveyor.yml</vh></v>
<v t="vitalije.20180822204714.1"><vh>RUST</vh>
<v t="vitalije.20190625073241.1"><vh>parsing leo xml</vh></v>
<v t="vitalije.20190702085616.1"><vh>rust attick</vh>
<v t="vitalije.20190701152643.1"><vh>main2</vh></v>
<v t="vitalije.20190626141101.1"><vh>ldf_header</vh></v>
</v>
<v t="vitalije.20180822204724.1"><vh>@clean src/lib.rs</vh>
<v t="vitalije.20191215163859.1"><vh>Tree, TreeIterator</vh></v>
<v t="vitalije.20191215164034.1"><vh>TREES</vh></v>
<v t="vitalije.20191215164048.1"><vh>module</vh>
<v t="vitalije.20191215164104.1"><vh>outline_from_str</vh></v>
<v t="vitalije.20191215182759.1"><vh>outline_from_file</vh></v>
<v t="vitalije.20191215183645.1"><vh>outline_from_leo_file</vh></v>
<v t="vitalije.20191215183719.1"><vh>outline_from_leo</vh></v>
<v t="vitalije.20191229172150.1"><vh>load_leo</vh></v>
<v t="vitalije.20191215164111.1"><vh>node_at</vh></v>
<v t="vitalije.20191215164117.1"><vh>iternodes</vh></v>
<v t="vitalije.20191215194010.1"><vh>drop_tree</vh></v>
<v t="vitalije.20191216171715.1"><vh>at_files</vh></v>
<v t="vitalije.20191217044239.1"><vh>tree_len</vh></v>
</v>
</v>
<v t="vitalije.20190702073134.1"><vh>@clean src/model.rs</vh>
<v t="vitalije.20190625101129.1"><vh>LevGnx</vh>
<v t="vitalije.20190702093107.1"><vh>LevGnx implementation</vh></v>
</v>
<v t="vitalije.20190625110116.1"><vh>Outline</vh>
<v t="vitalije.20190702093035.1"><vh>Outline implementation</vh>
<v t="vitalije.20190625121525.1"><vh>has</vh></v>
<v t="vitalije.20190625121531.1"><vh>find</vh></v>
<v t="vitalije.20190625121537.1"><vh>subtree</vh></v>
<v t="vitalije.20190625121544.1"><vh>add_node</vh></v>
<v t="vitalije.20190625122338.1"><vh>parent_index</vh></v>
<v t="vitalije.20190625145720.1"><vh>subtree_size</vh></v>
<v t="vitalije.20190625145812.1"><vh>child_index</vh></v>
</v>
</v>
<v t="vitalije.20190702100427.1"><vh>gnx_index</vh></v>
<v t="vitalije.20190625161035.1"><vh>VData</vh></v>
<v t="vitalije.20191216165607.1"><vh>find_derived_files</vh>
<v t="vitalije.20191216165649.1"><vh>adjust for @path</vh></v>
</v>
<v t="vitalije.20191229164057.1"><vh>combine_trees</vh></v>
</v>
<v t="vitalije.20190702073410.1"><vh>@clean src/utils.rs</vh>
<v t="vitalije.20190625101104.1"><vh>b64 ints</vh>
<v t="vitalije.20190625102142.1"><vh>constants ...</vh></v>
</v>
<v t="vitalije.20190626141051.1"><vh>rpartition</vh></v>
<v t="vitalije.20190702085650.1"><vh>tests</vh>
<v t="vitalije.20190630113842.1"><vh>test_rpartition</vh></v>
</v>
</v>
<v t="vitalije.20190625192155.1"><vh>@clean src/parsing.rs</vh>
<v t="vitalije.20190630112527.1"><vh>test</vh>
<v t="vitalije.20190630151934.1"><vh>test_handle_level_stars</vh></v>
</v>
<v t="vitalije.20190630144259.1"><vh>LdfParseState</vh></v>
<v t="vitalije.20190630144250.1"><vh>handle_line</vh>
<v t="vitalije.20190630155031.1"><vh>helpers...</vh>
<v t="vitalije.20190630145512.1"><vh>afterws</vh></v>
<v t="vitalije.20190630145518.1"><vh>tonl</vh></v>
<v t="vitalije.20190630150332.1"><vh>tocolon</vh></v>
<v t="vitalije.20190630153727.1"><vh>tocloseref</vh></v>
<v t="vitalije.20190701152016.1"><vh>to_start_of_bytes</vh></v>
<v t="vitalije.20190630145524.1"><vh>afternl</vh></v>
<v t="vitalije.20190630154640.1"><vh>push_body_line</vh></v>
</v>
<v t="vitalije.20190630154632.1"><vh>handle_leo_line</vh>
<v t="vitalije.20190630152746.1"><vh>check_at_plus_node</vh>
<v t="vitalije.20190630151224.1"><vh>handle_level_stars</vh></v>
</v>
<v t="vitalije.20190630154729.1"><vh>check_at_minus_others</vh></v>
<v t="vitalije.20190630154919.1"><vh>check_at_minus_ref</vh></v>
<v t="vitalije.20190630154613.1"><vh>check_at_plus_ref</vh></v>
<v t="vitalije.20190630154620.1"><vh>check_at_plus_others</vh></v>
<v t="vitalije.20190701193905.1"><vh>check_at_plus_all</vh></v>
<v t="vitalije.20190701194037.1"><vh>check_at_minus_all</vh></v>
<v t="vitalije.20190630192319.1"><vh>check_leo_directives</vh></v>
<v t="vitalije.20190701194331.1"><vh>check_at_verbatim</vh></v>
<v t="vitalije.20190701195722.1"><vh>check_at_raw</vh></v>
<v t="vitalije.20190630192331.1"><vh>check_ignored_sentinels</vh></v>
<v t="vitalije.20190701145231.1"><vh>check_at_first</vh></v>
<v t="vitalije.20190701145239.1"><vh>check_at_plus_at</vh></v>
</v>
</v>
<v t="vitalije.20190630160440.1"><vh>handle_leo_header</vh></v>
<v t="vitalije.20190630155744.1"><vh>ldf_parse</vh></v>
<v t="vitalije.20191215182251.1"><vh>from_derived_file</vh></v>
<v t="vitalije.20190702104313.1"><vh>from_derived_file_content</vh></v>
<v t="vitalije.20191215181220.1"><vh>parser_config</vh></v>
<v t="vitalije.20191215181042.1"><vh>from_leo_file</vh></v>
<v t="vitalije.20191215182704.1"><vh>from_leo_content</vh></v>
<v t="vitalije.20191229171155.1"><vh>load_with_external_files</vh></v>
</v>
<v t="vitalije.20190625205715.1"><vh>@clean src/main.rs</vh>
<v t="vitalije.20190701173234.1"><vh>pr_linebuf</vh></v>
</v>
<v t="vitalije.20190702113135.1"><vh>@clean src/bin/bmark.rs</vh>
<v t="vitalije.20190702113251.1"><vh>benchmark</vh></v>
</v>
<v t="vitalije.20190622142851.1"><vh>@clean src/bin/server.rs</vh>
<v t="vitalije.20190622150400.1"><vh>uses...</vh></v>
<v t="vitalije.20190622150335.1"><vh>main</vh></v>
<v t="vitalije.20190622150604.1"><vh>run</vh></v>
<v t="vitalije.20190622151201.1"><vh>Config</vh></v>
<v t="vitalije.20190622151325.1"><vh>parse_config_from_cmdline</vh></v>
<v t="vitalije.20190622153123.1"><vh>serve</vh></v>
<v t="vitalije.20190622153141.1"><vh>read_file</vh></v>
<v t="vitalije.20190622153151.1"><vh>handle_io_error</vh></v>
<v t="vitalije.20190622153201.1"><vh>file_path_mime</vh></v>
<v t="vitalije.20190622153212.1"><vh>local_path_for_request</vh></v>
<v t="vitalije.20190622153221.1"><vh>internal_server_error</vh></v>
<v t="vitalije.20190622153236.1"><vh>Error</vh></v>
</v>
<v t="vitalije.20190622191207.1"><vh>@clean src/bin/leoxml.rs</vh>
<v t="vitalije.20190622192134.1"><vh>parse_config_from_cmdline</vh></v>
<v t="vitalije.20190622192739.1"><vh>Error</vh></v>
<v t="vitalije.20190625101210.1"><vh>_test_levgnx</vh></v>
<v t="vitalije.20190625101337.1"><vh>_test_parse_leoxml</vh></v>
</v>
<v t="vitalije.20180822205209.1"><vh>@clean build.rs</vh></v>
<v t="vitalije.20180822204947.1"><vh>@clean Cargo.toml</vh></v>
</v>
<v t="vitalije.20180822170827.1"><vh>md:README.md</vh>
<v t="vitalije.20180822170827.2"><vh>Mini Leo</vh>
<v t="vitalije.20180822170827.3"><vh>Features</vh></v>
<v t="vitalije.20180822170827.4"><vh>Credits</vh></v>
</v>
</v>
<v t="vitalije.20180822164726.1"><vh>Doc</vh>
<v t="vitalije.20180822170856.1"><vh>md:AUTHORS.md</vh>
<v t="vitalije.20180822170856.2"><vh>Credits</vh>
<v t="vitalije.20180822170856.3"><vh>Development Lead</vh></v>
<v t="vitalije.20180822170856.4"><vh>Contributors</vh></v>
</v>
</v>
<v t="vitalije.20180822170901.1"><vh>md:CONTRIBUTING.md</vh>
<v t="vitalije.20180822171411.2"><vh>Contributing</vh>
<v t="vitalije.20180822171411.3"><vh>Types of Contributions</vh>
<v t="vitalije.20180822171411.4"><vh>Report Bugs</vh></v>
<v t="vitalije.20180822171411.5"><vh>Fix Bugs</vh></v>
<v t="vitalije.20180822171411.6"><vh>Implement Features</vh></v>
<v t="vitalije.20180822171411.7"><vh>Write Documentation</vh></v>
<v t="vitalije.20180822171411.8"><vh>Submit Feedback</vh></v>
</v>
<v t="vitalije.20180822171411.9"><vh>Get Started!</vh></v>
<v t="vitalije.20180822171411.10"><vh>Pull Request Guidelines</vh></v>
<v t="vitalije.20180822171411.11"><vh>Tips</vh></v>
<v t="vitalije.20180822171411.12"><vh>Deploying</vh></v>
</v>
</v>
<v t="vitalije.20180822170949.1"><vh>md:HISTORY.md</vh>
<v t="vitalije.20180822170949.2"><vh>History</vh>
<v t="vitalije.20180822170949.3"><vh>0.1.0 (2018-08-22)</vh></v>
</v>
</v>
<v t="vitalije.20180822171411.1"><vh>md:docs/contributing.md</vh>
<v t="vitalije.20180822171411.2"></v>
</v>
<v t="vitalije.20180822171443.1"><vh>md:docs/history.md</vh>
<v t="vitalije.20180822170949.2"></v>
</v>
<v t="vitalije.20180822171037.1"><vh>md:docs/index.md</vh>
<v t="vitalije.20180822171037.2"><vh>Welcome to Mini Leo's documentation!</vh></v>
</v>
<v t="vitalije.20180822171107.1"><vh>md:docs/installation.md</vh>
<v t="vitalije.20180822171107.2"><vh>Installation</vh>
<v t="vitalije.20180822171107.3"><vh>Stable release</vh></v>
<v t="vitalije.20180822171107.4"><vh>From sources</vh></v>
</v>
</v>
<v t="vitalije.20180822171113.1"><vh>md:docs/usage.md</vh>
<v t="vitalije.20180822171129.1"><vh>Usage</vh></v>
</v>
<v t="vitalije.20180822171159.1"><vh>md:docs/authors.md</vh>
<v t="vitalije.20180822170856.2"></v>
</v>
<v t="vitalije.20180822182319.1"><vh>md:docs/readme.md</vh>
<v t="vitalije.20180822170827.2"></v>
</v>
</v>
<v t="vitalije.20190702171525.1"><vh>Benchmark results</vh></v>
</vnodes>
<tnodes>
<t tx="vitalije.20180822151714.2">A minimal version of Leo editor</t>
<t tx="vitalije.20180822164726.1">s = '''AUTHORS.md
CONTRIBUTING.md
HISTORY.md
README.md
index.md
installation.md
usage.md
docs/authors.md
docs/contributing.md
docs/history.md
docs/index.md
docs/installation.md
docs/readme.md
docs/usage.md'''.split('\n')
for x in s:
    p1 = p.insertAsLastChild()
    p1.h = 'md:%s'%x
    p1.b = open(x, 'rt', encoding='utf8').read()

c.redraw()
</t>
<t tx="vitalije.20180822170827.1"></t>
<t tx="vitalije.20180822170827.2">[![image](https://img.shields.io/pypi/v/mini_leo.svg)](https://pypi.python.org/pypi/mini_leo)

[![image](https://img.shields.io/travis/vitalije/mini_leo.svg)](https://travis-ci.org/vitalije/mini_leo)

[![Documentation Status](https://readthedocs.org/projects/mini-leo/badge/?version=latest)](https://mini-leo.readthedocs.io/en/latest/?badge=latest)

A minimal version of Leo editor.

-   Free software: MIT license
-   Documentation: &lt;https://mini-leo.readthedocs.io&gt;.
</t>
<t tx="vitalije.20180822170827.3">-   TODO
</t>
<t tx="vitalije.20180822170827.4">This package was created with
[Cookiecutter](https://github.com/audreyr/cookiecutter) and the
[audreyr/cookiecutter-pypackage](https://github.com/audreyr/cookiecutter-pypackage)
project template.
</t>
<t tx="vitalije.20180822170856.1"></t>
<t tx="vitalije.20180822170856.2"></t>
<t tx="vitalije.20180822170856.3">-   Vitalije Milosevic _`&lt;vitalije (at) kviziracija.net&gt;`_
</t>
<t tx="vitalije.20180822170856.4">None yet. Why not be the first?
</t>
<t tx="vitalije.20180822170901.1"></t>
<t tx="vitalije.20180822170949.1"></t>
<t tx="vitalije.20180822170949.2"></t>
<t tx="vitalije.20180822170949.3">-   First release on PyPI.
</t>
<t tx="vitalije.20180822171037.1"></t>
<t tx="vitalije.20180822171037.2">- [Instalation](installation.md)
- [Usage](usage.md)
- [Contributing](contributing.md)
- [Authors](authors.md)
- [History](history.md)
</t>
<t tx="vitalije.20180822171107.1"></t>
<t tx="vitalije.20180822171107.2"></t>
<t tx="vitalije.20180822171107.3">To install Mini Leo, run this command in your terminal:

```shell
$ pip install mini_leo
```

This is the preferred method to install Mini Leo, as it will always
install the most recent stable release.

If you don't have [pip](https://pip.pypa.io) installed, this [Python
installation
guide](http://docs.python-guide.org/en/latest/starting/installation/)
can guide you through the process.
</t>
<t tx="vitalije.20180822171107.4">The sources for Mini Leo can be downloaded from the [Github
repo](https://github.com/vitalije/mini_leo).

You can either clone the public repository:

```shell
$ git clone git://github.com/vitalije/mini_leo
```

Or download the
[tarball](https://github.com/vitalije/mini_leo/tarball/master):

```shell
$ curl  -OL https://github.com/vitalije/mini_leo/tarball/master
```

Once you have a copy of the source, you can install it with:

```shell
$ python setup.py install
```
</t>
<t tx="vitalije.20180822171113.1"></t>
<t tx="vitalije.20180822171129.1">To use Mini Leo in a project:

    import mini_leo</t>
<t tx="vitalije.20180822171159.1"></t>
<t tx="vitalije.20180822171411.1"></t>
<t tx="vitalije.20180822171411.10">Before you submit a pull request, check that it meets these guidelines:

1.  The pull request should include tests.
2.  If the pull request adds functionality, the docs should be updated.
    Put your new functionality into a function with a docstring, and add
    the feature to the list in README.rst.
3.  The pull request should work for Python 2.7, 3.4, 3.5 and 3.6, and
    for PyPy. Check
    &lt;https://travis-ci.org/vitalije/mini_leo/pull_requests&gt; and make
    sure that the tests pass for all supported Python versions.
</t>
<t tx="vitalije.20180822171411.11">To run a subset of tests:

    $ py.test tests.test_mini_leo
</t>
<t tx="vitalije.20180822171411.12">A reminder for the maintainers on how to deploy. Make sure all your
changes are committed (including an entry in HISTORY.rst). Then run:

    $ bumpversion patch # possible: major / minor / patch
    $ git push
    $ git push --tags

Travis will then deploy to PyPI if tests pass.
</t>
<t tx="vitalije.20180822171411.2">Contributions are welcome, and they are greatly appreciated! Every
little bit helps, and credit will always be given.

You can contribute in many ways:
</t>
<t tx="vitalije.20180822171411.3"></t>
<t tx="vitalije.20180822171411.4">Report bugs at &lt;https://github.com/vitalije/mini_leo/issues&gt;.

If you are reporting a bug, please include:

-   Your operating system name and version.
-   Any details about your local setup that might be helpful in
    troubleshooting.
-   Detailed steps to reproduce the bug.
</t>
<t tx="vitalije.20180822171411.5">Look through the GitHub issues for bugs. Anything tagged with "bug"
and "help wanted" is open to whoever wants to implement it.
</t>
<t tx="vitalije.20180822171411.6">Look through the GitHub issues for features. Anything tagged with
"enhancement" and "help wanted" is open to whoever wants to
implement it.
</t>
<t tx="vitalije.20180822171411.7">Mini Leo could always use more documentation, whether as part of the
official Mini Leo docs, in docstrings, or even on the web in blog posts,
articles, and such.
</t>
<t tx="vitalije.20180822171411.8">The best way to send feedback is to file an issue at
&lt;https://github.com/vitalije/mini_leo/issues&gt;.

If you are proposing a feature:

-   Explain in detail how it would work.
-   Keep the scope as narrow as possible, to make it easier to
    implement.
-   Remember that this is a volunteer-driven project, and that
    contributions are welcome :)
</t>
<t tx="vitalije.20180822171411.9">Ready to contribute? Here's how to set up mini_leo for local
development.

1.  Fork the mini_leo repo on GitHub.
2.  Clone your fork locally:

        $ git clone git@github.com:your_name_here/mini_leo.git

3.  Install your local copy into a virtualenv. Assuming you have
    virtualenvwrapper installed, this is how you set up your fork for
    local development:

        $ mkvirtualenv mini_leo
        $ cd mini_leo/
        $ python setup.py develop

4.  Create a branch for local development:

        $ git checkout -b name-of-your-bugfix-or-feature

    Now you can make your changes locally.

5.  When you're done making changes, check that your changes pass
    flake8 and the tests, including testing other Python versions with
    tox:

        $ flake8 mini_leo tests
        $ python setup.py test or py.test
        $ tox

    To get flake8 and tox, just pip install them into your virtualenv.

6.  Commit your changes and push your branch to GitHub:

        $ git add .
        $ git commit -m "Your detailed description of your changes."
        $ git push origin name-of-your-bugfix-or-feature

7.  Submit a pull request through the GitHub website.
</t>
<t tx="vitalije.20180822171443.1"></t>
<t tx="vitalije.20180822171822.1">import subprocess
import re
import shutil
import os
pat = re.compile(r'^(\s*)LEOGNX:(.+)$')
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
@others
px = c.rootPosition()
seen = set()
while px:
    if px.gnx in seen:
        px.moveToNodeAfterTree()
        continue
    seen.add(px.gnx)
    if px.h.startswith('md:'):
        obradi(px)
        px.moveToNodeAfterTree()
    else:
        px.moveToThreadNext()
c.save()
c.fileCommands.save_ref()
</t>
<t tx="vitalije.20180822171822.2">def hl(p, lev):
    return '#' * (lev) + ' ' + p.h + '\n'</t>
<t tx="vitalije.20180822171822.3">def mdlines(p, lev=0):
    if lev &gt; 0 and not p.b.startswith('#'):
        yield hl(p, lev)
        yield ''
    for line in p.b.splitlines(False):
        m = pat.match(line)
        if m:
            v = c.fileCommands.gnxDict.get(m.group(2))
            if not v:
                g.es('gnx not found:[%s]'%m.group(2))
            else:
                for x in v.b.splitlines(False):
                    yield m.group(1) + x
            continue
        yield line
    yield ''
    for p1 in p.children():
        yield from mdlines(p1, lev + 1)
    yield ''</t>
<t tx="vitalije.20180822171822.4">_CACHE_ = {}
def getf(fname):
    if fname in _CACHE_:
        return _CACHE_[fname]
    if not g.os_path_exists(fname): return ''
    with open(fname, 'rt') as inpt:
        s = inpt.read()
        _CACHE_[fname] = s
        return s
</t>
<t tx="vitalije.20180822171822.5">def putf(fname, cnt):
    if cnt == getf(fname):
        return False
    with open(fname, 'wb') as out:
        out.write(cnt.encode('utf-8'))
        _CACHE_[fname] = cnt
        return True</t>
<t tx="vitalije.20180822171822.6">def obradi(p):
    fname = g.os_path_join(c.openDirectory, p.h[3:].strip())
    s = '\n'.join(mdlines(p))
    putf(fname, s)
    g.es('wrote', fname, len(s), 'bytes')
</t>
<t tx="vitalije.20180822173307.1"></t>
<t tx="vitalije.20180822182319.1"></t>
<t tx="vitalije.20180822183813.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""The setup script."""


from setuptools import setup, find_packages
import os
cargobin = os.path.expanduser('~/.cargo/bin/cargo')
with open('README.md') as readme_file:
    readme = readme_file.read()

with open('HISTORY.md') as history_file:
    history = history_file.read()

requirements = ['Click&gt;=6.0', 'milksnake']

setup_requirements = ['pytest-runner', 'milksnake']
test_requirements = ['pytest', ]
@others
setup(
    author="Vitalije Milosevic",
    author_email='vitalije@kviziracija.net',
    classifiers=[
        'Development Status :: 2 - Pre-Alpha',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Natural Language :: English',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
    ],
    description="A minimal version of Leo editor.",
    entry_points={
        'console_scripts': [
            'mini_leo=mini_leo.cli:main',
        ],
    },
    install_requires=requirements,
    license="MIT license",
    long_description=readme + '\n\n' + history,
    include_package_data=True,
    keywords='mini_leo',
    name='mini_leo',
    packages=find_packages(include=['mini_leo']),
    setup_requires=setup_requirements,
    test_suite='tests',
    tests_require=test_requirements,
    url='https://github.com/vitalije/mini_leo',
    version='0.1.0',
    zip_safe=False,
    platforms='any',
    milksnake_tasks = [build_native]
)

</t>
<t tx="vitalije.20180822200124.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e"># -*- coding: utf-8 -*-
"""Top-level package for Mini Leo."""
from mini_leo._native import ffi, lib
def test():
    return lib.a_function_from_rust()

__author__ = """Vitalije Milosevic"""
__email__ = 'vitalije@kviziracija.net'
__version__ = '0.1.0'
</t>
<t tx="vitalije.20180822200508.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e"># -*- coding: utf-8 -*-
"""Console script for mini_leo."""
import sys
import click
from mini_leo import test
@click.command()
def main(args=None):
    """Console script for mini_leo."""
    #click.echo("See click documentation at http://click.pocoo.org/")
    if test() != 42:
        return 1
    return 0
if __name__ == "__main__":
    sys.exit(main())  # pragma: no cover
</t>
<t tx="vitalije.20180822200526.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e"># -*- coding: utf-8 -*-
"""Main module."""
</t>
<t tx="vitalije.20180822200550.2">@click.command()
def main(args=None):
    """Console script for mini_leo."""
    #click.echo("See click documentation at http://click.pocoo.org/")
    if test() != 42:
        return 1
    return 0
</t>
<t tx="vitalije.20180822200821.1">for v in c.all_unique_nodes():
    if v.h.startswith('@file '):
        v.h = v.h.replace('@file ', '@clean ')
</t>
<t tx="vitalije.20180822204714.1">@path rust</t>
<t tx="vitalije.20180822204724.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">mod model;
mod utils;
mod parsing;
use std::collections::HashMap;
use std::sync::{Mutex};
pub use crate::parsing::{ldf_parse,from_derived_file_content, from_derived_file,
                         from_leo_file, from_leo_content, load_with_external_files};
pub use crate::utils::{b64int, b64str};
pub use crate::model::{VData, Outline, LevGnx, LevGnxOps, gnx_index, find_derived_files};
use pyo3::prelude::*;
use pyo3::PyIterProtocol;
use pyo3::{wrap_pyfunction};
use pyo3::type_object::PyTypeObject;
//use xml::reader::{ParserConfig, XmlEvent};
use std::path::{PathBuf};
#[macro_use]
extern crate lazy_static;

#[pyfunction]
pub fn a_function_from_rust() -&gt; PyResult&lt;i32&gt; {
    Ok(42)
}
@others
</t>
<t tx="vitalije.20180822204947.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">[package]
name = "mini_leo"
version = "0.1.0"
build = "build.rs"
edition = "2018"

[lib]
name = "mini_leo"
crate-type = ["cdylib"]

[build-dependencies]
cbindgen = "0.5.2"

[dependencies]
lazy_static = "1.4.0"
#clap = "2.33.0"
#error-type = "0.1.2"
#futures = "0.1.27"
#http = "0.1.17"
#hyper = "0.12"
#mime = "0.3.13"
#tokio-fs = "0.1.6"
#tokio-io = "0.1.12"
#xml-rs = "0.8.0"
quick-xml = "0.17.1"
nom = "5.0.0"
#sxd-document = "0.3.2"
#threadpool = "1.7.1"
#net2 = "0.2.33"
#libc = "0.2.58"
[dependencies.pyo3]
version = "0.8.4"
features = ["extension-module"]

[[bin]]
name = "server"
path = "src/bin/server.rs"

[[bin]]
name = "leoxml"
path = "src/bin/leoxml.rs"

[[bin]]
name = "test"
path = "src/main.rs"

[[bin]]
name = "bmark"
path = "src/bin/bmark.rs"</t>
<t tx="vitalije.20180822205209.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">extern crate cbindgen;

use std::env;

fn main() {
  let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
  let mut config: cbindgen::Config = Default::default();
  config.language = cbindgen::Language::C;
  match cbindgen::generate_with_config(&amp;crate_dir, config) {
    Ok(x) =&gt; x.write_to_file("target/mini_leo.h"),
    Err(e) =&gt; println!("Greska: {}", e)
  }
}

</t>
<t tx="vitalije.20180823001012.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">#!/bin/bash
curl https://sh.rustup.rs -sSf -o /tmp/rustup.sh
sh /tmp/rustup.sh --default-toolchain nightly -y
</t>
<t tx="vitalije.20190622133345.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Tests for `mini_leo` package."""

import pytest

from click.testing import CliRunner

from mini_leo import cli


@pytest.fixture
def response():
    """Sample pytest fixture.

    See more at: http://doc.pytest.org/en/latest/fixture.html
    """
    # import requests
    # return requests.get('https://github.com/audreyr/cookiecutter-pypackage')


def test_content(response):
    """Sample pytest test function with the pytest fixture as an argument."""
    # from bs4 import BeautifulSoup
    # assert 'GitHub' in BeautifulSoup(response.content).title.string


def test_command_line_interface():
    """Test the CLI."""
    runner = CliRunner()
    result = runner.invoke(cli.main)
    assert result.exit_code == 0
    help_result = runner.invoke(cli.main, ['--help'])
    assert help_result.exit_code == 0
    assert '--help  Show this message and exit.' in help_result.output
</t>
<t tx="vitalije.20190622142851.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
extern crate hyper;
#[macro_use]
extern crate error_type;

extern crate futures;
extern crate clap;
// extern crate tokio_fs;
@others
</t>
<t tx="vitalije.20190622150335.1">fn main() {
  if let Err(e) = run() {
    println!("Error: {}", e.description());
  }
}
</t>
<t tx="vitalije.20190622150400.1">use clap::App;

use futures::{future::Either};

use hyper::{header, Body, Request, Response, Server};
use hyper::rt::Future;
use hyper::service::service_fn;

use hyper::http::status::StatusCode;

use std::{
  error::Error as StdError,
  io,
  net::SocketAddr,
  path::{Path, PathBuf}
};</t>
<t tx="vitalije.20190622150604.1">fn run() -&gt; Result&lt;(), Error&gt; {
  let config = parse_config_from_cmdline()?;
  let Config {addr, root_dir, .. } = config;
  let server = Server::bind(&amp;addr)
    .serve(move || {
      let root_dir = root_dir.clone();
      service_fn(move |req| serve(req, &amp;root_dir.clone()))
    })
    .map_err(|e| {
      println!("There was an error: {}", e);
    });

  hyper::rt::run(server);
  Ok(())
}</t>
<t tx="vitalije.20190622151201.1">#[derive(Clone)]
struct Config {
  addr: SocketAddr,
  root_dir: PathBuf,
  file_name: PathBuf
}</t>
<t tx="vitalije.20190622151325.1">fn parse_config_from_cmdline() -&gt; Result&lt;Config, Error&gt; {
  let matches = App::new("Leo server")
    .version(env!("CARGO_PKG_VERSION"))
    .about("Server that serves Leo outline and its external files")
    .args_from_usage(
      "&lt;FILE&gt; 'leo outline file'
       [ADDR] -a --addr=[ADDR] 'sets the IP:PORT combination (default \"127.0.0.1:4000\")'"
    ).get_matches();
  let addr = matches.value_of("ADDR").unwrap_or("127.0.0.1:4000");
  let fname_arg = matches.value_of("FILE").unwrap();
  let fname_a = std::env::current_dir()?.with_file_name(fname_arg);
  let fname_b = Path::new(fname_arg);

  let root_dir = if fname_b.is_relative() {
    fname_a.parent().unwrap()
  } else {
    fname_b.parent().unwrap()
  };

  let file_name = root_dir.join(fname_b.file_name().unwrap());
  println!("file: [{}]", file_name.display());
  println!("root_dir: [{}]", root_dir.display());
  println!("addr: [{}]", addr);
  Ok(Config {
    addr: addr.parse()?,
    root_dir: PathBuf::from(root_dir),
    file_name: file_name
  })
}
</t>
<t tx="vitalije.20190622153123.1">// The function that returns a future of http responses for each hyper Request
// that is received. Errors are turned into an Error response (404 or 500).
fn serve(
    req: Request&lt;Body&gt;,
    root_dir: &amp;PathBuf,
) -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    let uri_path = req.uri().path();
    if let Some(path) = local_path_for_request(&amp;uri_path, root_dir) {
        Either::A(tokio_fs::file::File::open(path.clone()).then(
            move |open_result| match open_result {
                Ok(file) =&gt; Either::A(read_file(file, path)),
                Err(e) =&gt; Either::B(handle_io_error(e)),
            },
        ))
    } else {
        Either::B(internal_server_error())
    }
}</t>
<t tx="vitalije.20190622153141.1">// Read the file completely and construct a 200 response with that file as
// the body of the response.
fn read_file&lt;'a&gt;(
    file: tokio_fs::File,
    path: PathBuf,
) -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    let buf: Vec&lt;u8&gt; = Vec::new();
    tokio_io::io::read_to_end(file, buf)
        .map_err(Error::Io)
        .and_then(move |(_, buf)| {
            let mime_type = file_path_mime(&amp;path);
            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_LENGTH, buf.len() as u64)
                .header(header::CONTENT_TYPE, mime_type.as_ref())
                .body(Body::from(buf))
                .map_err(Error::from)
        })
}</t>
<t tx="vitalije.20190622153151.1">// Handle the one special io error (file not found) by returning a 404, otherwise
// return a 500
fn handle_io_error(error: io::Error) -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    match error.kind() {
        io::ErrorKind::NotFound =&gt; Either::A(futures::future::result(
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::empty())
                .map_err(Error::from),
        )),
        _ =&gt; Either::B(internal_server_error()),
    }
}</t>
<t tx="vitalije.20190622153201.1">fn file_path_mime(file_path: &amp;Path) -&gt; mime::Mime {
    let mime_type = match file_path.extension().and_then(std::ffi::OsStr::to_str) {
        Some("html") =&gt; mime::TEXT_HTML,
        Some("css") =&gt; mime::TEXT_CSS,
        Some("js") =&gt; mime::TEXT_JAVASCRIPT,
        Some("jpg") =&gt; mime::IMAGE_JPEG,
        Some("png") =&gt; mime::IMAGE_PNG,
        Some("svg") =&gt; mime::IMAGE_SVG,
        Some("wasm") =&gt; "application/wasm".parse::&lt;mime::Mime&gt;().unwrap(),
        _ =&gt; mime::TEXT_PLAIN,
    };
    mime_type
}</t>
<t tx="vitalije.20190622153212.1">fn local_path_for_request(request_path: &amp;str, root_dir: &amp;Path) -&gt; Option&lt;PathBuf&gt; {
    // This is equivalent to checking for hyper::RequestUri::AbsoluteUri
    if !request_path.starts_with("/") {
        return None;
    }
    // Trim off the url parameters starting with '?'
    let end = request_path.find('?').unwrap_or(request_path.len());
    let request_path = &amp;request_path[0..end];

    // Append the requested path to the root directory
    let mut path = root_dir.to_owned();
    if request_path.starts_with('/') {
        path.push(&amp;request_path[1..]);
    } else {
        return None;
    }

    // Maybe turn directory requests into index.html requests
    if request_path.ends_with('/') {
        path.push("index.html");
    }

    Some(path)
}</t>
<t tx="vitalije.20190622153221.1">fn internal_server_error() -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    futures::future::result(
        Response::builder()
            .status(StatusCode::INTERNAL_SERVER_ERROR)
            .header(header::CONTENT_LENGTH, 0)
            .body(Body::empty()),
    )
    .map_err(Error::from)
}</t>
<t tx="vitalije.20190622153236.1">// The custom Error type that encapsulates all the possible errors
// that can occur in this crate. This macro defines it and
// automatically creates Display, Error, and From implementations for
// all the variants.
error_type! {
    #[derive(Debug)]
    enum Error {
        Io(io::Error) { },
        HttpError(http::Error) { },
        AddrParse(std::net::AddrParseError) { },
        Std(Box&lt;StdError + Send + Sync&gt;) {
            desc (e) e.description();
        },
        ParseInt(std::num::ParseIntError) { },
    }
}</t>
<t tx="vitalije.20190622191207.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2

#[path="../model.rs"]
mod model;

extern crate xml;
extern crate clap;
#[macro_use]
extern crate error_type;
use crate::model::{VData, LevGnx, LevGnxOps, Outline, OutlineOps};
use std::collections::HashMap;
use clap::App;
use xml::reader::{ParserConfig, XmlEvent};

fn parser_config() -&gt; ParserConfig {
  ParserConfig::new()
      .cdata_to_characters(true)
      .whitespace_to_characters(true)
}

use std::{
  error::Error as StdError,
  io,
  io::{Read, BufReader},
  fs::File,
  path::{PathBuf}
};
@others

fn main() {
  let fname = parse_config_from_cmdline().unwrap();
  let (o, nodes) = _test_parse_leoxml(fname);
  let s_lev = ".............................................................";
  for x in o {
    let lev = 2 * x.level() as usize;
    let ignx = x.ignx() as usize;
    let h = &amp;nodes[ignx].h;
    let sz = nodes[ignx].b.len();
    println!("{}{}:[{}]", &amp;s_lev[..lev], h, sz);
  }
  _test_levgnx();
}</t>
<t tx="vitalije.20190622192134.1">fn parse_config_from_cmdline() -&gt; Result&lt;PathBuf, Error&gt; {
  let matches = App::new("Leo server")
    .version(env!("CARGO_PKG_VERSION"))
    .about("Server that serves Leo outline and its external files")
    .args_from_usage(
      "&lt;FILE&gt; 'leo outline file'"
    ).get_matches();
  Ok(PathBuf::from(matches.value_of("FILE").unwrap()))
}
</t>
<t tx="vitalije.20190622192739.1">// The custom Error type that encapsulates all the possible errors
// that can occur in this crate. This macro defines it and
// automatically creates Display, Error, and From implementations for
// all the variants.
error_type! {
    #[derive(Debug)]
    enum Error {
        Io(io::Error) { },
        HttpError(http::Error) { },
        AddrParse(std::net::AddrParseError) { },
        Std(Box&lt;StdError + Send + Sync&gt;) {
            desc (e) e.description();
        },
        ParseInt(std::num::ParseIntError) { },
    }
}</t>
<t tx="vitalije.20190625073241.1">we need:
    - list of known gnxes
    - stack of parent gnxes
    - list of pairs (level, gnx)
    - map gnx -&gt; list of direct child gnxes
    - map gnx -&gt; (h, b)

type 

struct LeoXmlTracker {
    index: Vec&lt;String&gt;,
    ancestors: Vec&lt;String&gt;,
    outline: Vec&lt;u32&gt;
}

Known facts:
    1. when we receive Characters(t) event and last started element is vh,
       then we have h for the last gnx in the outline
    2. when we receive StartElement(v) we should:
        2.1 add its t attribute and level
            to the list of pairs (level, gnx)
        2.2 add its t attribute to children of its parent gnx
        2.3 if it is clone, we should add all its subtree to the outline list
    3. when we receive StartElement(t) clear bodybuf and set bodygnx to be tx attribute
    4. when we receive EndElement(t) update h_b map bodygnx -&gt; b=bodybuf
    </t>
<t tx="vitalije.20190625101104.1">/// converts integer to String in base 64
pub fn b64str(n:u32) -&gt; String {
  if n == 0 {
    String::from("0")
  } else {
    let mut res = String::new();
    let mut _n = n;
    while _n &gt; 0 {
      res.insert(0, B64DIGITS[(_n &amp; 63) as usize]);
      _n = _n &gt;&gt; 6;
    }
    res
  }
}

/// converts base 64 str to u32
pub fn b64int(a:&amp;str) -&gt; u32 {
  let mut res = 0_u32;
  for i in a.bytes() {
    let k = B64VALUES[(i &amp; 127) as usize];
    if k == 255 { break }
    res = (res &lt;&lt; 6) + (k as u32);
  }
  res
}</t>
<t tx="vitalije.20190625101129.1">pub type LevGnx = u32;
pub trait LevGnxOps {
  /// returns level of this object
  fn level(&amp;self) -&gt; u8;

  /// returns ignx of this object
  fn ignx(&amp;self) -&gt; u32;

  /// increments level of this object
  fn inc(&amp;mut self);

  /// decrements level of this object
  fn dec(&amp;mut self);

  /// changes the level of this object for given delta d
  fn shift(&amp;mut self, d: i8);

  /// sets ignx of this object to given value
  fn set_ignx(&amp;mut self, ignx:u32);

  /// converts this object into ascii representation (4 ascii letters)
  fn to_str(&amp;self) -&gt; String;

  /// creates object from its String representation
  fn from_str(a:&amp;str) -&gt; LevGnx;
}
</t>
<t tx="vitalije.20190625101210.1">fn _test_levgnx() {
  let mut a:LevGnx = 23;
  println!("Ignx {}", a.ignx());
  println!("level {}", a.level());
  a.inc();
  println!("level {}", a.level());
  a.shift(5i8);
  println!("level {}", a.level());
  a.dec();
  println!("level {}", a.level());
  println!("levgnx {}", LevGnx::from_str("01234").to_str());
}</t>
<t tx="vitalije.20190625101337.1">fn _test_parse_leoxml(fname:PathBuf) -&gt; (Outline, Vec&lt;VData&gt;) {
  let f = File::open(&amp;fname).unwrap();
  let mut buf_reader = BufReader::new(f);
  let mut buf = String::new();
  buf_reader.read_to_string(&amp;mut buf).unwrap();
  let config = parser_config();
  let reader = config.create_reader(buf.as_bytes());
  let mut nodes:Vec&lt;VData&gt; = Vec::new();
  nodes.push(VData::new("hidden-root-vnode-gnx"));
  let mut gnx2i:HashMap&lt;String, usize&gt; = HashMap::new();
  let mut names:Vec&lt;String&gt; = Vec::new();
  let mut last_gnx = String::new();
  let mut txt = String::new();
  let mut lev = 0u8;
  let mut gnxcount:usize = 1;
  let mut outline:Outline = vec![0u32];
  for xe in reader.into_iter() {
    match xe {
      Ok(XmlEvent::StartElement { name, attributes, ..}) =&gt; {
        let n = name.local_name;
        names.push(n.clone());
        if n == "v" {
          last_gnx.clear();
          last_gnx.push_str(&amp;attributes[0].value);
          let v = VData::new(&amp;last_gnx);
          let ignx = gnx2i.entry(v.gnx.clone()).or_insert(gnxcount);
          lev += 1u8;
          outline.add_node(lev, *ignx as u32);
          nodes.push(v);
          gnxcount += 1;
        } else if n == "vnodes" {
          lev=0;
        } else if n == "t" {
          last_gnx.clear();
          last_gnx.push_str(&amp;attributes[0].value);
        }
        txt.clear();
      },
      Ok(XmlEvent::Characters(t)) =&gt; txt.push_str(&amp;t),
      Ok(XmlEvent::EndElement{..}) =&gt; {
        let n = names.pop().unwrap();
        if n == "vh" {
          if let Some(i) = gnx2i.get(&amp;last_gnx) {
            nodes[*i].h.push_str(&amp;txt)
          }
        } else if n == "v" {
          lev -= 1;
        } else if n == "t" {
          if let Some(i) = gnx2i.get(&amp;last_gnx) {
            nodes[*i].b.push_str(&amp;txt);
          }
        }
      },
      _ =&gt; ()
    }
  }
  (outline, nodes)
}</t>
<t tx="vitalije.20190625102142.1">const B64DIGITS:[char;64] = [
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
  'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
  'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c',
  'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
  'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
  't', 'u', 'v', 'w', 'x', 'y', 'z', '~'
];
const B64VALUES:[u8; 128] = [
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
    0u8,   1u8,   2u8,   3u8,   4u8,   5u8,   6u8,   7u8,
    8u8,   9u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8,  10u8,  11u8,  12u8,  13u8,  14u8,  15u8,  16u8,
   17u8,  18u8,  19u8,  20u8,  21u8,  22u8,  23u8,  24u8,
   25u8,  26u8,  27u8,  28u8,  29u8,  30u8,  31u8,  32u8,
   33u8,  34u8,  35u8, 255u8, 255u8, 255u8, 255u8,  36u8,
  255u8,  37u8,  38u8,  39u8,  40u8,  41u8,  42u8,  43u8,
   44u8,  45u8,  46u8,  47u8,  48u8,  49u8,  50u8,  51u8,
   52u8,  53u8,  54u8,  55u8,  56u8,  57u8,  58u8,  59u8,
   60u8,  61u8,  62u8, 255u8, 255u8, 255u8,  63u8, 255u8
];</t>
<t tx="vitalije.20190625110116.1">pub type Outline = Vec&lt;u32&gt;;

pub trait OutlineOps {
  /// returns true if this outline conains a node with given ignx
  fn has(&amp;self, ignx:u32) -&gt; bool;

  /// returns the index of the first node with the given ignx
  /// if the node can't be found returns -1
  fn find(&amp;self, ignx:u32) -&gt; i64;

  /// returns suboutline of the node with the given ignx
  /// if such a node dosen't exist returns an empty outline
  fn subtree(&amp;self, ignx:u32) -&gt; Outline;

  /// appends a node with the given ignx at the given level.
  /// Returns true if the node is clone and its subtree has been added too;
  /// otherwise returns false.
  fn add_node(&amp;mut self, level: u8, ignx: u32) -&gt; bool;

  /// returns the index of the parent node
  fn parent_index(&amp;self, i: usize) -&gt; usize;

  /// returns the size of the subtree starting at given index
  fn subtree_size(&amp;self, i:usize) -&gt; usize;

  /// Given the node located at the given outline index i
  /// this method returns the child index that this node
  /// has in its parent's list of children
  fn child_index(&amp;self, i:usize) -&gt; usize;

}
</t>
<t tx="vitalije.20190625121525.1">/// returns true if this outline conains a node with given ignx
fn has(&amp;self, ignx:u32) -&gt; bool { self.find(ignx) &gt; -1}</t>
<t tx="vitalije.20190625121531.1">/// returns the index of the first node with the given ignx
/// if the node can't be found returns -1
fn find(&amp;self, ignx:u32) -&gt; i64 {
  let mut i = 0i64;
  for x in self {
    if (x &amp; 0x3ffff) == ignx {return i}
    i += 1;
  }
  -1
}</t>
<t tx="vitalije.20190625121537.1">/// returns suboutline of the node with the given ignx
/// if such a node dosen't exist returns an empty outline
fn subtree(&amp;self, ignx:u32) -&gt; Outline {
  let mut res:Outline = Vec::new();
  let j = self.find(ignx);
  if j &lt; 0 { return res }
  let mut i = j as usize;
  let z = self[i];
  let zlev:u8 = z.level();
  let delta:i8 = -(zlev as i8);
  res.push(z.ignx());
  let n = self.len();
  while i + 1 &lt; n {
    i += 1;
    let mut z = self[i];
    if z.level() &lt;= zlev { break };
    z.shift(delta);
    res.push(z);
  }
  res
}</t>
<t tx="vitalije.20190625121544.1">/// appends a node with the given ignx at the given level.
/// Returns true if the node is clone and its subtree has been added too;
/// otherwise returns false.
fn add_node(&amp;mut self, level: u8, ignx: u32) -&gt; bool {
  let max_level:u8 = match self.last() {
    Some(z) =&gt; z.level() + 1,
    None =&gt; 0
  };
  if level &gt; max_level {
    panic!("trying to add a node to level {} when max_level is {}", level, max_level);
  }
  let st = self.subtree(ignx);
  if st.is_empty() {
    self.push(((level as u32) &lt;&lt; 18) | ignx);
    false
  } else {
    for x in st {
      let mut z = x;
      z.shift(level as i8);
      self.push(z);
    }
    true
  }
}</t>
<t tx="vitalije.20190625122338.1">/// returns the index of the parent node
fn parent_index(&amp;self, i: usize) -&gt; usize {
  return match self.get(i) {
    Some(z) =&gt; if z.level() &lt; 2 {
        0
      } else {
        let mut j = i - 1;
        let lev = z.level() - 1;
        while self[j].level() != lev {j -= 1}
        j
      },
    None =&gt; 0
  }
}</t>
<t tx="vitalije.20190625145720.1">/// returns the size of the subtree starting at given index
fn subtree_size(&amp;self, i:usize) -&gt; usize {
  let z:u32 = self[i] &amp; 0xffc_0000;
  for (j, x) in self[i..].iter().enumerate() {
    if z &gt; *x {return j + 1}
  }
  self.len() - i
}</t>
<t tx="vitalije.20190625145812.1">/// Given the node located at the given outline index i
/// this method returns the child index that this node
/// has in its parent's list of children
fn child_index(&amp;self, i:usize) -&gt; usize {
  let pi = self.parent_index(i);
  let mut n:usize = 0;
  let lev = self[i].level();
  for z in &amp;self[pi..i] {
    if z.level() == lev {n += 1}
  }
  n
}
</t>
<t tx="vitalije.20190625161035.1">#[pyclass]
pub struct VData {
  #[pyo3(get, set)]
  pub gnx: String,
  #[pyo3(get, set)]
  pub h: String,
  #[pyo3(get, set)]
  pub b: String,
  #[pyo3(get, set)]
  pub flags: u16
}

#[pymethods]
impl VData {
  #[new]
  fn pynew(obj: &amp;PyRawObject, _gnx:&amp;str) {
    obj.init(VData::new(_gnx));
  }
}
impl VData {
  pub fn new(_gnx:&amp;str) -&gt; VData {
    VData {
      gnx: String::from(_gnx),
      h:String::new(),
      b:String::new(),
      flags:1
    }
  }
  pub fn clone(&amp;self) -&gt; VData {
    VData {
      gnx: self.gnx.clone(),
      h: self.h.clone(),
      b: self.b.clone(),
      flags: self.flags
    }
  }
  pub fn is_expanded(&amp;self) -&gt; bool {self.flags &amp; 1 == 1}
}</t>
<t tx="vitalije.20190625192155.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
use super::model::{VData, Outline, OutlineOps, LevGnx, LevGnxOps, combine_trees, find_derived_files};
use quick_xml::Reader as XmlReader;
use quick_xml::events::Event;
use quick_xml::events::attributes::Attributes;

use std::{
  io,
  io::{Read, BufReader},
  fs,
  fs::File,
  path::{PathBuf},
  collections::{HashMap}
};

@others
</t>
<t tx="vitalije.20190625205715.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
extern crate nom;
mod parsing;
mod model;
use std::env::args;
use parsing::{ldf_parse,from_derived_file_content};
use std::io;
use std::io::prelude::*;
use std::fs::File;
@others

fn main() -&gt; io::Result&lt;()&gt;{
  let mut buffer = String::new();
  let mut kind:usize = 0;
  for (i, a) in args().enumerate() {
    if i == 1 {
      let f = File::open(a)?;
      let mut reader = io::BufReader::new(f);
      buffer.clear();
      reader.read_to_string(&amp;mut buffer)?;
    } else if i == 2 {
      kind = a.parse().expect("Not a number");
    }
  }
  if kind == 0 {
    pr_ldf(&amp;buffer);
  } else {
    let (o, nodes) = from_derived_file_content(&amp;buffer);
    if let Some(v) = nodes.get(kind) {
      println!("head:{}\ngnx:{}\nbody:{}", v.h, v.gnx, v.b);
    }
  }
  Ok(())
}
</t>
<t tx="vitalije.20190626141051.1">/*
pub fn rpartition&lt;'a&gt;(input:&amp;'a str, sep:&amp;str) -&gt; (&amp;'a str, &amp;'a str, &amp;'a str) {
  match input.rfind(sep) {
    Some(i) =&gt; {
      let j = i + sep.len();
      (&amp;input[..i], &amp;input[i..j], &amp;input[j..])
    },
    None =&gt; {
      let i = input.len() - 1;
      (&amp;input, &amp;input[i..i], &amp;input[i..i])
    }
  }
}
*/
pub fn partition&lt;'a&gt;(input:&amp;'a str, sep:&amp;str) -&gt; (&amp;'a str, &amp;'a str, &amp;'a str) {
  match input.find(sep) {
    Some(i) =&gt; {
      let j = i + sep.len();
      (&amp;input[..i], &amp;input[i..j], &amp;input[j..])
    },
    None =&gt; {
      let i = input.len() - 1;
      (&amp;input, &amp;input[i..i], &amp;input[i..i])
    }
  }
}
</t>
<t tx="vitalije.20190626141101.1">/*
extern crate nom;
use nom::{
  IResult,
  bytes::complete::take_until, //{is_not, is_a, tag, take, take_until, take_while},
  // character::complete::{none_of, one_of, line_ending, char as pchar},
  sequence::pair, //{tuple, pair, preceded},
  //branch::alt,
  // multi::{many_till},
  combinator::map,
  //error::ErrorKind
};

pub fn ldf_header(input:&amp;str) -&gt;  IResult&lt;&amp;str, (&amp;str, &amp;str, &amp;str)&gt; {
  let w1 = take_until("@+leo-ver=5-thin");
  let w2 = pair(w1, take_until("\n"));
  let w3 = map(w2, |(a, b)| {
    let (f, _, st) = rpartition(a, "\n");
    (f, st, &amp;b[16..])
  });
  w3(input)
}
*/</t>
<t tx="vitalije.20190630112527.1">#[cfg(test)]
mod tests {
  @others
}</t>
<t tx="vitalije.20190630113842.1">#[test]
fn test_rpartition() {
  let s = "asepbsepc";
  let res = super::rpartition(s, "sep");
  assert_eq!(res, ("asepb", "sep", "c"));
  let res2 = super::rpartition(s, "d");
  assert_eq!(res2, ("asepbsepc", "", ""));
  let res3 = super::rpartition(s, "a");
  assert_eq!(res3, ("", "a", "sepbsepc"));
}</t>
<t tx="vitalije.20190630144250.1">type NodesBuf = Vec&lt;(usize, usize, usize, usize, usize)&gt;;
type LinesBuf = Vec&lt;(usize, usize, usize, Option&lt;(&amp;'static str, &amp;'static str)&gt;)&gt;;

/// handles a line in derived file
/// if it is ordinary line appends its start, end to the
/// current body
/// else if it is special leo sentinel
/// handles it by changing state or adding a node
fn handle_line&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf){
  let i0 = state.ind;
  let a = afterws(state.buf, i0);

  if state.buf[a..].starts_with(state.st.as_bytes()) &amp;&amp;
    state.buf[(a + state.st.len())] == b'@' {
      // it is a leo sentinel
      state.ind = a + state.st.len() + 1;
      if state.in_all {
        handle_leo_line_in_all(state, nodes, lines)
      } else {
        handle_leo_line(state, a - i0, nodes, lines)
      }
  } else {
    state.ind = afternl(state.buf, a);
    if state.in_doc {
      let a = i0 + state.st.len() + 1;
      let b = state.ind - 1 - state.en.len();
      push_body_line(state, a, b, Some(("", "\n")), lines);
    } else {
      let a = state.ind;
      push_body_line(state, i0, a, None, lines);
    }
  }
}
</t>
<t tx="vitalije.20190630144259.1">struct LdfParseState&lt;'a&gt; {
  ind:usize,
  st:&amp;'a str,
  en:&amp;'a str,
  buf:&amp;'a [u8],
  indents: Vec&lt;usize&gt;,
  mark:usize,
  in_doc:bool,
  path: Vec&lt;usize&gt;,
  first_start: usize,
  first_end: usize,
  last_start: usize,
  // in_raw:bool,
  in_all:bool
}</t>
<t tx="vitalije.20190630145512.1">fn afterws(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; buf[j] == b' ' {
    j += 1;
  }
  j
}</t>
<t tx="vitalije.20190630145518.1">fn tonl(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; buf[j] != b'\n' {
    j += 1;
  }
  j
}</t>
<t tx="vitalije.20190630145524.1">fn afternl(buf:&amp;[u8], i:usize) -&gt; usize { tonl(buf, i) + 1}</t>
<t tx="vitalije.20190630150332.1">fn tocolon(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; buf[j] != b':' {
    j += 1;
  }
  j
}
// fn aftercolon(buf:&amp;[u8], i:usize) -&gt; usize { tocolon(buf, i) + 1 }</t>
<t tx="vitalije.20190630151224.1">fn handle_level_stars(buf:&amp;[u8], i:usize) -&gt; (usize, usize) {
  if buf[i + 1] == b'*' {
    // i - star; i + 1 star; i + 2 space
    (2, i + 3)
  } else if buf[i + 1] == b' ' {
    (1, i + 2)
  } else {
    let mut j = i + 1;
    let mut k = 0;
    while buf[j] != b'*' {
      k = 10 * k + ((buf[j] - b'0') as usize);
      j += 1;
    }
    (k, j + 2)
  }
}</t>
<t tx="vitalije.20190630151934.1">#[test]
fn test_handle_level_stars() {
  let s = b"#@+node:ekr.20050208101229: ** &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (2, 31));
  let s = b"#@+node:ekr.20050208101229: *4* &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (4, 32));
  let s = b"#@+node:ekr.20050208101229: *14* &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (14, 33));
  let s = b"#@+node:ekr.20050208101229: * &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (1, 30))
}</t>
<t tx="vitalije.20190630152746.1">fn check_at_plus_node&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       nodes:&amp;mut NodesBuf,
                       _lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+node:") {
    let a = i0 + 6;
    let b = tocolon(state.buf, a);
    let (lev, c) = handle_level_stars(state.buf, b + 2);
    let d = tonl(state.buf, c);
    nodes.push((lev, a, b, c, d - state.en.len()));
    if let Some(ni) = state.path.last_mut() {
      *ni = nodes.len();
    }
    state.ind = d + 1;
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630153727.1">fn tocloseref(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; !buf[j..].starts_with(b"&gt;&gt;") {
    j += 1;
  }
  j
}
// fn aftercloseref(buf:&amp;[u8], i:usize) -&gt; usize { tocloseref(buf, i) + 2 }</t>
<t tx="vitalije.20190630154613.1">fn check_at_plus_ref&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+&lt;&lt;") {
    let a = i0 + 1;
    let b = tocloseref(state.buf, a + 2);
    let ni = *(state.path.last().unwrap());
    let wi = *(state.indents.last().unwrap());
    let d = a - 2 - state.st.len();
    let c = d - ws + wi;
    lines.push((ni, c, d, None));
    lines.push((ni, a, b + 2, None));
    state.indents.push(ws);
    state.path.push(0);
    state.ind = afterws(state.buf, afternl(state.buf, state.ind));
    check_at_plus_node(state, nodes, lines);
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630154620.1">fn check_at_plus_others&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+others") {
    let j = afternl(state.buf, i0 + 7);
    let i1 = i0 - state.st.len() - 1 - ws;
    push_body_line(state, i1, i1 + ws, Some(("", "@others")), lines);
    let ni = *state.path.last().unwrap();
    lines.push((ni, i0 + 7, j, None));
    state.indents.push(ws);
    state.path.push(0);
    state.ind = afterws(state.buf, afternl(state.buf, state.ind));
    check_at_plus_node(state, nodes, lines);
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630154632.1">fn handle_leo_line&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf){
  let _ =  check_at_plus_node(state, nodes, lines)
        || check_at_plus_others(state, ws, nodes, lines)
        || check_at_plus_ref(state, ws, nodes, lines)
        || check_at_minus_others(state, nodes, lines)
        || check_at_minus_ref(state, nodes, lines)
        || check_at_plus_at(state, lines)
        || check_at_plus_all(state, ws, nodes, lines)
        || check_at_first(state, lines)
        || check_at_verbatim(state, lines)
        || check_at_raw(state, lines)
        || check_leo_directives(state, ws, lines)
        || check_ignored_sentinels(state)
        || unknown_leo_sentinel(state);
}
fn handle_leo_line_in_all&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf){
   let _ = false
        || check_at_verbatim(state, lines)
        || check_at_plus_node(state, nodes, lines)
        || check_at_minus_all(state, nodes, lines);
}
fn unknown_leo_sentinel(state:&amp;LdfParseState) -&gt; bool {
  let a = state.ind - 2;
  let b = tonl(state.buf, a);
  let _s = std::str::from_utf8(&amp;state.buf[a..b]).unwrap();
  //println!("unknown leo sentinel:[{}] at index:{}", _s, state.ind);
  false //panic!("error");
}
</t>
<t tx="vitalije.20190630154640.1">fn push_body_line&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
  a: usize,
  b: usize,
  e: Option&lt;(&amp;'static str, &amp;'static str)&gt;,
  lines:&amp;mut LinesBuf) {
  if a &gt; b {panic!("push_body_line a &gt; b {} &gt; {}", a, b);}
  let ni = *state.path.last().unwrap();
  let wi = *state.indents.last().unwrap();
  if b - a == 1 {
    lines.push((ni, a, b, e))
  } else {
    lines.push((ni, a + wi, b, e))
  }
}</t>
<t tx="vitalije.20190630154729.1">fn check_at_minus_others&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       _nodes:&amp;mut NodesBuf,
                       _lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"-others") {
    state.ind = afternl(state.buf, i0 + 7);
    state.path.pop();
    state.indents.pop();
    state.in_doc = false;
    true
  } else {
    false
  }
}
</t>
<t tx="vitalije.20190630154919.1">fn check_at_minus_ref&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       _nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"-&lt;&lt;") {
    let i1 = afternl(state.buf, i0 + 4);
    let i2 = afterws(state.buf, i1);
    let i3 = i2 + state.st.len();
    state.path.pop();
    state.indents.pop();
    let ni = state.path.last().unwrap();
    if state.buf[i2..].starts_with(state.st.as_bytes()) &amp;&amp;
      state.buf[i3..].starts_with(b"@afterref") {
      let i4 = afternl(state.buf, i3 + 9); // after sentinel
      let i5 = afternl(state.buf, i4); // line of text
      lines.push((*ni, i4, i5, None));
      state.ind = i5;
    } else {
      lines.push((*ni, i1 - 1,  i1, None));
      state.ind = i1;
    }
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630155031.1"></t>
<t tx="vitalije.20190630155744.1">pub fn ldf_parse&lt;'a&gt;(txt:&amp;'a str) -&gt; (NodesBuf, LinesBuf, usize, usize) {
  let mut nodes:NodesBuf = vec![(0,0,0,0,0)];
  let mut lines:LinesBuf = Vec::new();
  let mut state = handle_leo_header(txt);
  let n = txt.len();
  while state.ind &lt; n {
    if is_at_minus_leo(&amp;mut state) &amp;&amp; !state.in_all{ break }
    handle_line(&amp;mut state, &amp;mut nodes, &amp;mut lines)
  }
  (nodes, lines, state.first_end, state.last_start)
}
fn is_at_minus_leo&lt;'a&gt;(state:&amp;mut LdfParseState) -&gt; bool {
  let a = state.ind;
  let b = state.ind + state.st.len();
  if state.buf[a..].starts_with(state.st.as_bytes()) &amp;&amp; state.buf[b..].starts_with(b"@-leo") {
    state.last_start = afternl(state.buf, b + 5);
    state.ind = state.last_start;
    true
  } else { false}
}
</t>
<t tx="vitalije.20190630160440.1">fn handle_leo_header&lt;'a&gt;(txt:&amp;'a str) -&gt; LdfParseState&lt;'a&gt; {
  let mut state = LdfParseState {
    ind: 0,
    st: "",
    en: "",
    buf: txt.as_bytes(),
    indents: vec![0],
    mark:0,
    in_doc: false,
    path: vec![0],
    first_start:0,
    first_end: 0,
    last_start:txt.len(),
    in_all:false,
    // in_raw:false
  };
  let n = txt.len();
  while state.ind &lt; n {
    if state.buf[state.ind] == b'\n' {
      state.ind += 1;
      state.mark = state.ind;
    } else if state.buf[state.ind..].starts_with(b"@+leo-ver=5-thin") {
      state.first_end = state.mark;
      state.st = &amp;txt[state.mark..state.ind];
      let a = state.ind + 16;
      state.ind = tonl(state.buf, a);
      state.en = &amp;txt[a..state.ind];
      state.ind += 1;
      break;
    } else {
      state.ind += 1;
    }
  }
  state
}</t>
<t tx="vitalije.20190630192319.1">fn check_leo_directives(state:&amp;mut LdfParseState, ws:usize, lines:&amp;mut LinesBuf) -&gt; bool {
  if state.buf[state.ind] == b'@' {
    if state.buf[state.ind..].starts_with(b"@c") || state.buf[state.ind..].starts_with(b"@code") {
      state.in_doc = false;
    }
    let c = tonl(state.buf, state.ind);
    let a = state.ind - ws;
    let b = c - state.en.len();
    push_body_line(state, a, b, Some(("", "\n")), lines);
    state.ind = c + 1;
    true
  } else { false }
}</t>
<t tx="vitalije.20190630192331.1">fn check_ignored_sentinels(state:&amp;mut LdfParseState) -&gt; bool {
  let a = state.buf[state.ind..].starts_with(b"@first")
      ||  state.buf[state.ind..].starts_with(b"@first")
      ||  state.buf[state.ind..].starts_with(b"@first")
      ||  state.buf[state.ind..].starts_with(b"@first");
  if a {
    state.ind = afternl(state.buf, state.ind);
  }
  a
}</t>
<t tx="vitalije.20190701145231.1">fn check_at_first&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;, lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"@first"){
    let i = state.first_start;
    let j = afternl(state.buf, i);
    state.first_start = j;
    lines.push((2, i, j, Some(("@first ", ""))));
    state.ind = afternl(state.buf, i0 + 6);
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190701145239.1">fn check_at_plus_at&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;, lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  let f1 = state.buf[i0..].starts_with(b"+at");
  let f2 = state.buf[i0..].starts_with(b"+doc");
  if f1 || f2 {
    let a = if f1 { i0 + 3} else {i0 + 4};
    let f3 = state.en.len() &gt; 0 &amp;&amp; state.buf[a..].starts_with(state.en.as_bytes());
    let f4 = state.en.len() == 0 &amp;&amp; state.buf[a] == b'\n';
    let ni = *(state.path.last().unwrap());
    if f3 || f4 {
      let opt = if f1 { Some(("@", "")) } else { Some(("@doc", "")) };
      let b = a + state.en.len();
      push_body_line(state, b, b + 1, opt, lines);
      state.ind = b + 1;
    } else {
      let opt = if f1 { Some(("@ ", "\n")) } else { Some(("@doc ", "\n")) };
      let b = tonl(state.buf, a) - state.en.len();
      lines.push((ni, a + 1, b, opt));
      state.ind = b + 1;
    }
    if state.en.len() != 0 {
      let wi = state.indents.last().unwrap();
      let mut a = afternl(state.buf, state.ind) + wi;
      let mut i = a;
      while !state.buf[i..].starts_with(state.en.as_bytes()) {
        if state.buf[i] == b'\n' {
          lines.push((ni, a, i+1, None));
          i += wi + 1;
          a = i;
        } else {
          i += 1;
        }
      }
      state.ind = afternl(state.buf, i);
      state.in_doc = false;
    } else {
      state.in_doc = true;
    }
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190701152016.1">/* fn to_start_of_bytes(buf:&amp;[u8], i:usize, s:&amp;[u8]) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; !buf[j..].starts_with(s) {
    j += 1;
  }
  j
}
*/</t>
<t tx="vitalije.20190701152643.1">fn main2(data:&amp;[u8], nt:usize) {
  let datastr = std::str::from_utf8(data).unwrap();
  let (nodes, lines, _first_end, _last_start) = ldf_parse(datastr);
  let mut s = String::new();
  for (ni, a, b, e) in lines {
    if ni == nt + 1 {
      match e {
        Some((pref, suf)) =&gt; {
         s.push_str(pref);
          s.push_str(&amp;datastr[a..b]);
          s.push_str(suf);
        },
        None =&gt; s.push_str(&amp;datastr[a..b])
      }
    }
  }
  if let Some((_lev, _a, _b, c, d)) = nodes.get(nt) {
    println!("{}", &amp;datastr[*c..*d]);
    println!("{}", s);
  } else {
    println!("unknown node {}", nt);
  }
}

</t>
<t tx="vitalije.20190701173234.1">type BufNode = (usize, usize, usize, usize, usize);
type BufLine = (usize, usize, usize, Option&lt;(&amp;'static str, &amp;'static str)&gt;);

fn pr_bufline(s:&amp;BufLine) {
  let (ni, a, b, op) = *s;
  let pref_suf = match op {
    Some((pref, suf)) =&gt;  format!("\"{}\", \"{}\"", pref.escape_debug(), suf.escape_debug()),
    _ =&gt; String::from("null, null")
  };
  print!("[{}, {}, {}, {}]", ni, a, b, &amp;pref_suf);
}
fn pr_bufnode(s:&amp;BufNode) {
  let (a, b, c, d, e) = *s;
  print!("[{}, {}, {}, {}, {}]", a, b, c, d, e);
}
fn pr_ldf(datastr:&amp;str) {
  let (nodes, lines, _first_end, _last_start) = ldf_parse(datastr);
  println!("{}\n \"nodes\": [", "{");
  let n = nodes.len() - 1;
  for (i, x) in nodes.iter().enumerate() {
    print!("    ");
    pr_bufnode(x);
    if i != n {println!(",")}
  }
  println!("],\n  \"lines\": [");
  let n = lines.len() - 1;
  for (i, x) in lines.iter().enumerate() {
    print!("    ");
    pr_bufline(x);
    if i != n {println!(",")}
  }
  println!("]\n{}", "}");
}</t>
<t tx="vitalije.20190701193905.1">fn check_at_plus_all&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+all") {
    let i1 = i0 - state.st.len() - 1 - ws;
    push_body_line(state, i1, i1 + ws, Some(("", "@all\n")), lines);
    state.indents.push(ws);
    state.path.push(0);
    state.ind = afterws(state.buf, afternl(state.buf, state.ind));
    check_at_plus_node(state, nodes, lines);
    state.in_doc = false;
    state.in_all = true;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190701194037.1">fn check_at_minus_all&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       _nodes:&amp;mut NodesBuf,
                       _lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"-all") {
    state.ind = afternl(state.buf, i0 + 4);
    state.path.pop();
    state.indents.pop();
    state.in_doc = false;
    state.in_all = false;
    true
  } else {
    false
  }
}
</t>
<t tx="vitalije.20190701194331.1">fn check_at_verbatim(state:&amp;mut LdfParseState, lines:&amp;mut LinesBuf) -&gt; bool {
  if state.buf[state.ind..].starts_with(b"verbatim") {
    let a = afternl(state.buf, state.ind + 8);
    let b = afternl(state.buf, a);
    let ni = *(state.path.last().unwrap());
    lines.push((ni, a, b, None));
    state.ind = b;
    true
  } else { false }
}</t>
<t tx="vitalije.20190701195722.1">fn check_at_raw(state:&amp;mut LdfParseState, lines:&amp;mut LinesBuf) -&gt; bool {
  if state.buf[state.ind..].starts_with(b"verbatim") {
    let a = afternl(state.buf, state.ind + 9);
    let b = afternl(state.buf, a);
    let ni = *(state.path.last().unwrap());
    lines.push((ni, a, b, None));
    state.ind = b;
    true
  } else { false }
}</t>
<t tx="vitalije.20190702073134.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
#[path="utils.rs"]
mod utils;
use self::utils::{b64str, b64int, partition};
use std::collections::HashMap;
use pyo3::prelude::*;
use std::path::{PathBuf};
@others
</t>
<t tx="vitalije.20190702073410.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
@others
</t>
<t tx="vitalije.20190702085616.1"></t>
<t tx="vitalije.20190702085650.1">#[cfg(test)]
mod tests {
  @others
}</t>
<t tx="vitalije.20190702093035.1">impl OutlineOps for Outline {
  @others
}
</t>
<t tx="vitalije.20190702093107.1">impl LevGnxOps for LevGnx {

  /// returns level of this object
  fn level(&amp;self) -&gt; u8 {(((*self) &gt;&gt; 18) &amp; 63) as u8}

  /// returns ignx of this object
  fn ignx(&amp;self) -&gt; u32 {(*self) &amp; 0x3ffffu32}

  /// increments level of this object
  fn inc(&amp;mut self) {*self += 0x4ffffu32;}

  /// decrements level of this object
  fn dec(&amp;mut self) {if *self &gt; 0x3ffff {*self -= 0x4ffffu32;}}

  /// changes the level of this object for given delta d
  fn shift(&amp;mut self, d: i8) {
    let lev = ((*self &gt;&gt; 18) &amp; 63) as i8 + d;
    *self = (*self &amp; 0x3ffff) | if lev &lt;= 0 { 0 } else { ((lev as u32) &lt;&lt; 18)};
  }

  /// sets ignx of this object to given value
  fn set_ignx(&amp;mut self, ignx:u32) {
    *self = (*self &amp; 0xfc0000) | ignx;
  }

  /// converts this object into ascii representation (4 ascii letters)
  fn to_str(&amp;self) -&gt; String {
    let mut res = b64str(*self);
    while res.len() &lt; 4 {res.insert(0, '0');}
    res
  }

  /// creates object from its String representation
  fn from_str(a:&amp;str) -&gt; LevGnx {
    b64int(&amp;a[..4]) as LevGnx
  }
}</t>
<t tx="vitalije.20190702100427.1">/// returns a map of ignx -&gt; gnx
pub fn gnx_index(nodes:&amp;Vec&lt;VData&gt;) -&gt; HashMap&lt;&amp;str, u32&gt; {
  let mut res = HashMap::new();
  for (i, x) in nodes.iter().enumerate() {
    res.insert(x.gnx.as_str(), i as u32);
  }
  res
}</t>
<t tx="vitalije.20190702104313.1">pub fn from_derived_file_content(content:&amp;str) -&gt; (Outline, Vec&lt;VData&gt;) {
  let mut nodes = Vec::new();
  let mut outline = Vec::new();
  let (vnodes, lines, _, _) = ldf_parse(content);
  let mut i:u32 = 0;
  // TODO: consider changing ldf_parse to skip root node in its output nodes
  // if it skips root node, in the following loop we won't have to check if lev &gt; 0
  // and root node can be inserted in nodes before loop
  for (lev, a, b, c, d) in vnodes {
    if lev &gt; 0 {
      let mut v = VData::new(&amp;content[a..b]);
      v.h.push_str(&amp;content[c..d]);
      nodes.push(v);
      let mut x:LevGnx = i;
      x.shift(lev as i8);
      outline.push(x);
    } else {
      let mut v = VData::new("hidden-root-vnode-gnx");
      v.h.push_str("&lt;hidden root vnode&gt;");
      nodes.push(v)
    }
    i += 1;
  }
  for (i, a, b, op) in lines {
    let v = nodes.get_mut(i-1).unwrap();
    match op {
      Some((pref, suf)) =&gt; {
        v.b.push_str(pref);
        v.b.push_str(&amp;content[a..b]);
        v.b.push_str(suf);
      },
      _ =&gt; v.b.push_str(&amp;content[a..b])
    }
  }
  (outline, nodes)
}</t>
<t tx="vitalije.20190702113135.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
#[path="../parsing.rs"]
mod parsing;
use std::env::args;
use parsing::{ldf_parse,from_derived_file_content};
use std::io;
use std::io::prelude::*;
use std::fs::File;
@others
use std::time::{Instant};
fn main() -&gt; io::Result&lt;()&gt; {
  let mut buffer = String::new();
  for (i, a) in args().enumerate() {
    if i == 1 {
      let f = File::open(a)?;
      let mut reader = io::BufReader::new(f);
      buffer.clear();
      reader.read_to_string(&amp;mut buffer)?;
    }
  }
  benchmark(&amp;buffer);
  Ok(())
}
</t>
<t tx="vitalije.20190702113251.1">fn benchmark(datastr:&amp;str) {
  let mut n = 0;
  let t1 = Instant::now();
  for i in 0..100 {
     let (o, nodes) = from_derived_file_content(datastr);
     n += o.len() + nodes.len();
  }
  if n &lt; 100 {println!("less than 100 lines and nodes")}
  println!("{} ms", t1.elapsed().as_millis());
}</t>
<t tx="vitalije.20190702171525.1">Python 3.7.0 (default, Jun 28 2018, 13:15:42) 
[GCC 7.2.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; def f():
...     with open('leo/test/activeUnitTests.txt', 'r') as inp:
...       s = inp.read()
...       return _minileo.outline_from_str(s)
... 
&gt;&gt;&gt; import _minileo
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; print(timeit.timeit(f, number=100)/100*1000, 'ms')
6.344196610007202 ms</t>
<t tx="vitalije.20191215163859.1">struct Tree {
    outline: Outline,
    nodes: Vec&lt;VData&gt;,
}
#[pyclass]
struct TreeIterator {
    tree_id: usize,
    index: usize
}
#[pyproto]
impl PyIterProtocol for TreeIterator {
    fn __iter__(slf:PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Py&lt;TreeIterator&gt;&gt; {
        Ok(slf.into())
    }
    fn __next__(mut slf:PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Option&lt;(u8, VData)&gt;&gt; {
        let m = TREES.lock().unwrap();
        let res = m.get(&amp;slf.tree_id).map(|t|{
            let n = t.outline.len();
            if slf.index &lt; n {
                let levgnx = t.outline[slf.index];
                let i = levgnx.ignx() as usize;
                Some((levgnx.level(), t.nodes[i].clone()))
            } else {
                None
            }
        });
        slf.index += 1;
        match res {
            Some(Some(x)) =&gt; Ok(Some(x)),
            _ =&gt; Ok(None)
        }
    }
}</t>
<t tx="vitalije.20191215164034.1">lazy_static! {
    static ref TREES:Mutex&lt;Box&lt;HashMap&lt;usize,Tree&gt;&gt;&gt; = Mutex::new(Box::new(HashMap::new()));
}
</t>
<t tx="vitalije.20191215164048.1">#[pymodule]
fn _minileo(_py: Python, m:&amp;PyModule) -&gt; PyResult&lt;()&gt; {
    /// creates outline from str
    @others
    m.add_wrapped(wrap_pyfunction!(a_function_from_rust))?;
    m.add("VData", &lt;VData as PyTypeObject&gt;::type_object())?;
    Ok(())
}</t>
<t tx="vitalije.20191215164104.1">#[pyfn(m, "outline_from_str")]
fn outline_from_string(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
    let (outline, nodes) = from_derived_file_content(txt);
    let t = Tree {outline, nodes};
    let mut m = TREES.lock().unwrap();
    let tid = m.len();
    m.insert(tid, t);
    Ok(tid)
}</t>
<t tx="vitalije.20191215164111.1">#[pyfn(m, "node_at")]
fn node_at(_py: Python, tid:usize, i:usize) -&gt; PyResult&lt;Option&lt;(u8, VData)&gt;&gt; {
    let res = TREES.lock().unwrap().get(&amp;tid).map(|t|{
        let x = t.outline[i];
        let v = t.nodes[x.ignx() as usize].clone();
        (x.level(), v)
    });
    Ok(res)
}</t>
<t tx="vitalije.20191215164117.1">#[pyfn(m, "iternodes")]
fn iternodes(_py:Python, tid:usize) -&gt; PyResult&lt;TreeIterator&gt; {
    Ok(TreeIterator {tree_id:tid, index:0})
}</t>
<t tx="vitalije.20191215181042.1">pub fn from_leo_file(fname:PathBuf) -&gt; Result&lt;(Outline, Vec&lt;VData&gt;), io::Error&gt; {
  let f = File::open(&amp;fname)?;
  let mut buf_reader = BufReader::new(f);
  let mut buf = String::new();
  buf_reader.read_to_string(&amp;mut buf)?;
  Ok(from_leo_content(&amp;buf))
}</t>
<t tx="vitalije.20191215181220.1">/*
fn parser_config() -&gt; ParserConfig {
  ParserConfig::new()
      .cdata_to_characters(true)
      .whitespace_to_characters(true)
}
*/</t>
<t tx="vitalije.20191215182251.1">pub fn from_derived_file(fname:PathBuf) -&gt; Result&lt;(Outline, Vec&lt;VData&gt;), io::Error&gt; {
  let f = File::open(&amp;fname)?;
  let mut buf_reader = BufReader::new(f);
  let mut buf = String::new();
  buf_reader.read_to_string(&amp;mut buf)?;
  Ok(from_derived_file_content(&amp;buf))
}</t>
<t tx="vitalije.20191215182704.1">pub fn from_leo_content(buf:&amp;str) -&gt; (Outline, Vec&lt;VData&gt;) {
  //let config = parser_config();
  //let reader = config.create_reader(buf.as_bytes());
  let mut reader = XmlReader::from_str(buf);
  let mut nodes:Vec&lt;VData&gt; = Vec::new();
  nodes.push(VData::new("hidden-root-vnode-gnx"));
  let mut gnx2i:HashMap&lt;String, usize&gt; = HashMap::new();
  let mut last_gnx = String::new();
  let mut txt = String::new();
  let mut lev = 0u8;
  let mut gnxcount:usize = 1;
  let mut outline:Outline = vec![0u32];
  loop {
    let mut xmlbuf = Vec::new();
    let getattr = |k:&amp;[u8], attrs:Attributes, rr| {
      for x in attrs {
        let a = x.unwrap();
        if a.key == k {
          return a.unescape_and_decode_value(rr).unwrap();
        }
      }
      panic!("missing attribute:{:?}", k);
    };
    match reader.read_event(&amp;mut xmlbuf) {
      Ok(Event::Start(ref e)) =&gt; {
        let n = e.local_name();
        if n == b"v" {
          last_gnx.clear();
          last_gnx.push_str(&amp;getattr(b"t", e.attributes(), &amp;reader));
          let v = VData::new(&amp;last_gnx);
          let ignx = gnx2i.entry(v.gnx.clone()).or_insert(gnxcount);
          lev += 1u8;
          outline.add_node(lev, *ignx as u32);
          nodes.push(v);
          gnxcount += 1;
        } else if n == b"vnodes" {
          lev=0;
        } else if n == b"t" {
          last_gnx.clear();
          last_gnx.push_str(&amp;getattr(b"tx", e.attributes(), &amp;reader));
        }
        txt.clear();
      },
      Ok(Event::Text(e)) =&gt; txt.push_str(&amp;e.unescape_and_decode(&amp;reader).unwrap()),
      Ok(Event::End(ref e)) =&gt; {
        let n = e.local_name();
        if n == b"vh" {
          if let Some(i) = gnx2i.get(&amp;last_gnx) {
            nodes[*i].h.push_str(&amp;txt)
          }
        } else if n == b"v" {
          lev -= 1;
        } else if n == b"t" {
          if let Some(i) = gnx2i.get(&amp;last_gnx) {
            nodes[*i].b.push_str(&amp;txt);
          }
        }
      },
      Ok(Event::Eof) =&gt; break,
      _ =&gt; ()
    }
  }
  (outline, nodes)
}</t>
<t tx="vitalije.20191215182759.1">#[pyfn(m, "outline_from_file")]
fn outline_from_file(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
    match from_derived_file(PathBuf::from(txt)) {
        Ok((outline, nodes)) =&gt; {
            let t = Tree {outline, nodes};
            let mut m = TREES.lock().unwrap();
            let tid = m.len();
            m.insert(tid, t);
            Ok(tid)
        },
        Err(e) =&gt; Err(pyo3::exceptions::IOError::py_err(e.to_string()))
    }
}</t>
<t tx="vitalije.20191215183645.1">#[pyfn(m, "outline_from_leo_file")]
fn outline_from_leo_file(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
    match from_leo_file(PathBuf::from(txt)) {
        Ok((outline, nodes)) =&gt; {
            let t = Tree {outline, nodes};
            let mut m = TREES.lock().unwrap();
            let tid = m.len();
            m.insert(tid, t);
            Ok(tid)
        },
        Err(e) =&gt; Err(pyo3::exceptions::IOError::py_err(e.to_string()))
    }
}</t>
<t tx="vitalije.20191215183719.1">#[pyfn(m, "outline_from_leo_str")]
fn outline_from_leo_str(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
    let (outline, nodes) = from_leo_content(txt);
    let t = Tree {outline, nodes};
    let mut m = TREES.lock().unwrap();
    let tid = m.len();
    m.insert(tid, t);
    Ok(tid)
}
</t>
<t tx="vitalije.20191215194010.1">#[pyfn(m, "drop_tree")]
fn drop_tree(_py:Python, tid:usize) -&gt; PyResult&lt;bool&gt; {
    Ok(TREES.lock().unwrap().remove(&amp;tid).is_some())
}</t>
<t tx="vitalije.20191216165607.1">pub fn find_derived_files(folder:&amp;str, outline:&amp;Outline, nodes:&amp;Vec&lt;VData&gt;) -&gt; Vec&lt;(String, usize)&gt; {
  let mut stack = vec![PathBuf::from(folder)];
  let mut res = Vec::new();
  for (i, x) in outline.iter().enumerate() {
    let lev = x.level() as usize;
    let v = &amp;nodes[x.ignx() as usize];
    @others
    if v.h.starts_with("@file ") {
      let fname = v.h[6..].trim();
      let p = stack[stack.len() - 1].join(fname);
      match p.canonicalize() {
        Ok(x) =&gt; res.push((x.to_string_lossy().to_string(), i)),
        Err(e) =&gt; {println!("canonicalize error:{}[{:?}]", e, p);res.push((p.to_string_lossy().to_string(), i))}
      }
    }
  }
  res
}</t>
<t tx="vitalije.20191216165649.1">let np = if v.h.starts_with("@path ") {
  &amp;v.h[6..].trim()
} else if v.b.starts_with("@path ") {
  partition(&amp;v.b[6..], "\n").0.trim()
} else if let Some(i) = v.b.find("\n@path ") {
  partition(&amp;v.b[i+7..], "\n").0.trim()
} else {""};

if lev &lt; stack.len() { stack.drain(lev+1..); }

let mut nf = stack[stack.len() - 1].clone();
if np.len() &gt; 0 {
  nf.push(np);
}
stack.push(nf);
</t>
<t tx="vitalije.20191216171715.1">#[pyfn(m, "at_files")]
fn at_files(_py:Python, tid:usize, folder:&amp;str) -&gt; PyResult&lt;Vec&lt;(String, usize)&gt;&gt; {
    match TREES.lock().unwrap().get(&amp;tid).map(|t|{
        find_derived_files(folder, &amp;t.outline, &amp;t.nodes)
    }){
        Some(x) =&gt; Ok(x),
        None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
    }
}</t>
<t tx="vitalije.20191217044239.1">#[pyfn(m, "tree_len")]
fn tree_len(_py:Python, tid:usize) -&gt; PyResult&lt;usize&gt; {
    match TREES.lock().unwrap().get(&amp;tid).map(|t|{
        t.outline.len() - 1
    }){
        Some(x) =&gt; Ok(x),
        None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
    }
}</t>
<t tx="vitalije.20191229164032.1">^\s*(?:pub\s+)?fn\s+(\w+)\s*[(&lt;]
^\s*(?:pub\s+)?struct\s+(\w+)\s*[{]
^\s*(?:pub\s+)?impl\s+(\w+\s+for\s+\w+)\s*[{]
^\s*let\s+(?:mut\s+)?(\w+)\s*=\s*[|][^|]*[|]\s*(?:-&gt;|[{])</t>
<t tx="vitalije.20191229164057.1">pub fn combine_trees(trees:&amp;Vec&lt;(Outline, Vec&lt;VData&gt;)&gt;) -&gt; (Outline, Vec&lt;VData&gt;) {
  let mut catalog:HashMap&lt;&amp;str, (usize, usize)&gt; = HashMap::new();
  for (i, x) in trees.iter().enumerate() {
    let (o, n) = x;
    for y in o.iter() {
      let ignx = y.ignx() as usize;
      let gnx = n[ignx].gnx.as_str();
      catalog.insert(gnx, (i, ignx));
    }
  }
  let vclone = |v:&amp;VData| {
    let gnx = v.gnx.as_str();
    let (i, j) = catalog.get(gnx).unwrap();
    trees[*i].1[*j].clone()
  };
  let (o1, v1) = &amp;trees[0];
  let mut outline = vec![o1[0]];
  let mut vnodes:Vec&lt;VData&gt; = v1.iter().map(vclone).collect();
  let mut real_start = 0;
  let mut i = trees.len();
  let mut ignxes = gnx_index(&amp;v1);
  for (o, n) in trees.iter().rev() {
    i -= 1;
    if i == 0 {
      real_start = outline.len();
      for x in o.iter().skip(1) {
        let gnx = n[x.ignx() as usize].gnx.as_str();
        let ii = ignxes.get(gnx).unwrap();
        outline.add_node(x.level(), *ii);
      }
    } else {
      for v in n.iter() {
        let gnx = v.gnx.as_str();
        if !ignxes.contains_key(gnx) {
          let ii = ignxes.len() as u32;
          ignxes.insert(gnx, ii);
          vnodes.push(vclone(v));
        }
      }
      for x in o {
        let gnx = n[x.ignx() as usize].gnx.as_str();
        let ii = ignxes.get(gnx).unwrap();
        outline.add_node(x.level(), *ii);
      }
    }
  }
  outline.drain(1..real_start);
  (outline, vnodes)
}</t>
<t tx="vitalije.20191229171155.1">pub fn load_with_external_files(fname:&amp;str) -&gt; Result&lt;(Outline, Vec&lt;VData&gt;), io::Error&gt; {
  let pbuf = fs::canonicalize(fname)?;
  let xmlcont = fs::read_to_string(pbuf.as_path())?;
  let mut trees = Vec::new();
  let (outline, vnodes) = from_leo_content(xmlcont.as_str());
  let folder = pbuf.parent().unwrap();
  for (f,_) in find_derived_files(folder.to_str().unwrap(), &amp;outline, &amp;vnodes) {
    if let Ok(cont) = fs::read_to_string(f.as_str()) {
      trees.push(from_derived_file_content(cont.as_str()));
    } else {
      println!("file not found: [{}]", f.as_str());
    }
  }
  trees.insert(0, (outline, vnodes));
  Ok(combine_trees(&amp;trees))
}</t>
<t tx="vitalije.20191229172150.1">#[pyfn(m, "load_leo")]
fn load_leo(_py: Python, fname:&amp;str) -&gt; PyResult&lt;usize&gt; {
    let tid = match load_with_external_files(fname) {
        Ok((outline, nodes)) =&gt; {
            let t = Tree {outline, nodes};
            let mut m = TREES.lock().unwrap();
            let tid = m.len();
            m.insert(tid, t);
            tid
        },
        Err(e) =&gt; {
            println!("{}", e);
            0
        }
    };
    Ok(tid)
}</t>
<t tx="vitalije.20191230142308.1">def build_native(spec):
    # build a native rust library
    build = spec.add_external_build(
        cmd=[cargobin, 'build', '--lib', '--release'],
        path='rust'
    )

    spec.add_cffi_module(
        module_path='mini_leo._native',
        dylib=lambda: build.find_dylib('mini_leo', in_path='target/release'),
        header_filename=lambda: build.find_header('mini_leo.h', in_path='target'),
        rtld_flags=['NOW', 'NODELETE']
    )</t>
<t tx="vitalije.20191231151920.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">import os
import subprocess
import zipfile
import hashlib
import base64
import sys
from distutils.util import get_platform
PLATFORM = get_platform().replace('-', '_').replace('.', '_')
@others
if __name__ == '__main__':
    if not os.path.exists('dist'):
        os.makedirs('dist')
    make_wheel()</t>
<t tx="vitalije.20191231152226.1">def cargo_build():
    proc = subprocess.Popen('cargo build --lib --release',
        cwd='rust')
    proc.wait()</t>
<t tx="vitalije.20191231152252.1">METADATA = b'''
Metadata-Version: 2.1
Name: mini_leo
Version: 0.1.0
Summary: A minimal version of Leo editor.
Home-page: https://github.com/vitalije/mini_leo
Author: Vitalije Milosevic
Author-email: vitalije@kviziracija.net
License: MIT license
Keywords: mini_leo
Platform: any
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
'''.strip()
</t>
<t tx="vitalije.20191231152300.1">WHEEL = b'''
Wheel-Version: 1.0
Root-Is-Purelib: false
Tag: cp3-none-%s
'''%(PLATFORM.encode('utf8')).strip()
</t>
<t tx="vitalije.20191231153206.1">def getversion():
    return METADATA.partition(b'\nVersion:')[2].strip().partition(b'\n')[0].decode('utf8')</t>
<t tx="vitalije.20191231155959.1">def make_wheel():
    if sys.platform == 'linux':
        makelinux_wheel()
    elif sys.platform == 'win32':
        makewin_wheel()</t>
<t tx="vitalije.20191231160001.1">def makelinux_wheel():
    s = open('rust/target/release/libmini_leo.so', 'rb').read()
    makeany_wheel('mini_leo/_minileo.so', s)</t>
<t tx="vitalije.20191231160004.1">def makewin_wheel():
    s = open('rust/target/release/mini_leo.dll', 'rb').read()
    makeany_wheel('mini_leo/_minileo.pyd', s)</t>
<t tx="vitalije.20191231160008.1">def makeany_wheel(dllname, dllcont):
    ver = getversion()
    zf = zipfile.ZipFile('dist/mini_leo-%s-cp3-none-%s.whl'%(ver, PLATFORM), 'w')
    def fline(f, cont):
        return '%s,sha256=%s,%d'%(
                f,
                base64.urlsafe_b64encode(hashlib.sha256(cont).digest()).rstrip(b'=').decode('utf8'),
                len(cont)
            )
    buf = []
    def addf(f, cont):
        buf.append(fline(f, cont))
        zf.writestr(f, cont)
    addf(dllname, dllcont)
    addf('mini_leo/__init__.py', open('mini_leo/__init__.py', 'rb').read())
    dinfo = 'mini_leo-%s.dist-info/'%ver
    addf(dinfo + 'METADATA', METADATA)
    buf.append(dinfo + 'RECORD,,')
    addf(dinfo + 'WHEEL', WHEEL)
    zf.writestr(dinfo + 'RECORD', '\n'.join(buf).encode('utf8'))
    zf.close()</t>
<t tx="vitalije.20191231162159.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">version: 0.1.{build}
image: Visual Studio 2015
shallow_clone: true
clone_depth: 5
environment:
  PYTHON_VERSION: 3.7
  RUSTUP_INSTALLER_ADDRES_X64: https://win.rustup.rs/x86_64
  RUSTUP_INSTALLER_ADDRES_X32: https://win.rustup.rs/i686
cache:
  - '%USERPROFILE%\.cargo\'
  - 'rust\target\'
init:
  - set PYTHON=C:\PYTHON37-x64
  - set PATH=%PYTHON%;%PYTHON%\Scripts;%PATH%
  - dir C:\users\
  - python --version
install:
  - appveyor-retry appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe
  - rustup-init.exe -y --default-host=x86_64-pc-windows-msvc --profile=minimal --default-toolchain nightly
  - set PATH=%PATH%;%USERPROFILE%\.cargo\bin
platform: x64
build_script:
  - python build_wheel.py
artifacts:
    - path: dist\mini_leo*.whl</t>
</tnodes>
</leo_file>
