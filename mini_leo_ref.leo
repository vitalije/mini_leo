<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="vitalije.20180822151714.2"><vh>Start</vh>
<v t="vitalije.20180822200821.1"><vh>to clean</vh></v>
<v t="vitalije.20180822175121.1"><vh>@edit mkdocs.yml</vh></v>
<v t="vitalije.20180822175420.1"><vh>@edit .gitignore</vh></v>
<v t="vitalije.20180822184227.1"><vh>@edit .travis.yml</vh></v>
<v t="vitalije.20180822184624.1"><vh>@edit MANIFEST.in</vh></v>
<v t="vitalije.20180823001012.1"><vh>@clean rust-installer.sh</vh></v>
<v t="vitalije.20180823103429.1"><vh>@edit setup.cfg</vh></v>
<v t="vitalije.20180823104438.1"><vh>@edit SConstruct</vh></v>
<v t="vitalije.20180823104449.1"><vh>@edit pyproject.toml</vh></v>
<v t="vitalije.20180823132035.1"><vh>@edit requirements_dev.txt</vh></v>
<v t="vitalije.20180822185454.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580500000069636f6e7371035d71047d7105285804000000747970657106580400000066696c657107680758610000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f6175746f322e706e677108580700000072656c506174687109581900000066696c655f69636f6e732f66696c655f6175746f322e706e67710a58050000007768657265710b580e0000006265666f7265486561646c696e65710c5807000000796f6666736574710d4b005807000000786f6666736574710e4b02580400000078706164710f4b0158020000006f6e71105805000000766e6f64657111580a00000076697375616c49636f6e71125801000000317113756173732e"><vh>@auto tox.ini</vh></v>
<v t="vitalije.20180822173307.1"><vh>@settings</vh>
<v t="vitalije.20180822171822.1"><vh>@button n-save @key=Ctrl-s</vh>
<v t="vitalije.20180822171822.2"><vh>hl</vh></v>
<v t="vitalije.20180822171822.3"><vh>mdlines</vh></v>
<v t="vitalije.20180822171822.4"><vh>getf</vh></v>
<v t="vitalije.20180822171822.5"><vh>putf</vh></v>
<v t="vitalije.20180822171822.6"><vh>obradi</vh></v>
<v t="vitalije.20190622132803.7"><vh>save_history</vh></v>
</v>
</v>
</v>
<v t="vitalije.20180822200124.1"><vh>@clean mini_leo/__init__.py</vh></v>
<v t="vitalije.20180822200508.1"><vh>@clean mini_leo/cli.py</vh>
<v t="vitalije.20180822200550.2"><vh>main (cli.py)</vh></v>
</v>
<v t="vitalije.20180822200526.1"><vh>@clean mini_leo/mini_leo.py</vh></v>
<v t="vitalije.20190622133345.1"><vh>@clean tests/test_mini_leo.py</vh></v>
<v t="vitalije.20180822183813.1"><vh>@clean setup.py</vh>
<v t="vitalije.20180822204146.1"><vh>build_native</vh></v>
<v t="vitalije.20180822204202.1"><vh>setup</vh></v>
</v>
<v t="vitalije.20180822204714.1"><vh>RUST</vh>
<v t="vitalije.20190625073241.1"><vh>parsing leo xml</vh></v>
<v t="vitalije.20180822204724.1"><vh>@clean src/lib.rs</vh></v>
<v t="vitalije.20190622142851.1"><vh>@clean src/bin/server.rs</vh>
<v t="vitalije.20190622150400.1"><vh>uses...</vh></v>
<v t="vitalije.20190622150335.1"><vh>main</vh></v>
<v t="vitalije.20190622150604.1"><vh>run</vh></v>
<v t="vitalije.20190622151201.1"><vh>Config</vh></v>
<v t="vitalije.20190622151325.1"><vh>parse_config_from_cmdline</vh></v>
<v t="vitalije.20190622153123.1"><vh>serve</vh></v>
<v t="vitalije.20190622153141.1"><vh>read_file</vh></v>
<v t="vitalije.20190622153151.1"><vh>handle_io_error</vh></v>
<v t="vitalije.20190622153201.1"><vh>file_path_mime</vh></v>
<v t="vitalije.20190622153212.1"><vh>local_path_for_request</vh></v>
<v t="vitalije.20190622153221.1"><vh>internal_server_error</vh></v>
<v t="vitalije.20190622153236.1"><vh>Error</vh></v>
</v>
<v t="vitalije.20190622191207.1"><vh>@clean src/bin/leoxml.rs</vh>
<v t="vitalije.20190622192134.1"><vh>parse_config_from_cmdline</vh></v>
<v t="vitalije.20190622192739.1"><vh>Error</vh></v>
<v t="vitalije.20190625101104.1"><vh>b64 ints</vh>
<v t="vitalije.20190625102142.1"><vh>constants ...</vh></v>
</v>
<v t="vitalije.20190625101129.1"><vh>LevGnx</vh>
<v t="vitalije.20190625102834.1"><vh>LevGnxUtils implementation</vh></v>
</v>
<v t="vitalije.20190625101210.1"><vh>_test_levgnx</vh></v>
<v t="vitalije.20190625101337.1"><vh>_test_parse_leoxml</vh></v>
</v>
<v t="vitalije.20180822205209.1"><vh>@clean build.rs</vh></v>
<v t="vitalije.20180822204947.1"><vh>@clean Cargo.toml</vh></v>
</v>
<v t="vitalije.20180822170827.1"><vh>md:README.md</vh>
<v t="vitalije.20180822170827.2"><vh>Mini Leo</vh>
<v t="vitalije.20180822170827.3"><vh>Features</vh></v>
<v t="vitalije.20180822170827.4"><vh>Credits</vh></v>
</v>
</v>
<v t="vitalije.20180822164726.1"><vh>Doc</vh>
<v t="vitalije.20180822170856.1"><vh>md:AUTHORS.md</vh>
<v t="vitalije.20180822170856.2"><vh>Credits</vh>
<v t="vitalije.20180822170856.3"><vh>Development Lead</vh></v>
<v t="vitalije.20180822170856.4"><vh>Contributors</vh></v>
</v>
</v>
<v t="vitalije.20180822170901.1"><vh>md:CONTRIBUTING.md</vh>
<v t="vitalije.20180822171411.2"><vh>Contributing</vh>
<v t="vitalije.20180822171411.3"><vh>Types of Contributions</vh>
<v t="vitalije.20180822171411.4"><vh>Report Bugs</vh></v>
<v t="vitalije.20180822171411.5"><vh>Fix Bugs</vh></v>
<v t="vitalije.20180822171411.6"><vh>Implement Features</vh></v>
<v t="vitalije.20180822171411.7"><vh>Write Documentation</vh></v>
<v t="vitalije.20180822171411.8"><vh>Submit Feedback</vh></v>
</v>
<v t="vitalije.20180822171411.9"><vh>Get Started!</vh></v>
<v t="vitalije.20180822171411.10"><vh>Pull Request Guidelines</vh></v>
<v t="vitalije.20180822171411.11"><vh>Tips</vh></v>
<v t="vitalije.20180822171411.12"><vh>Deploying</vh></v>
</v>
</v>
<v t="vitalije.20180822170949.1"><vh>md:HISTORY.md</vh>
<v t="vitalije.20180822170949.2"><vh>History</vh>
<v t="vitalije.20180822170949.3"><vh>0.1.0 (2018-08-22)</vh></v>
</v>
</v>
<v t="vitalije.20180822171411.1"><vh>md:docs/contributing.md</vh>
<v t="vitalije.20180822171411.2"></v>
</v>
<v t="vitalije.20180822171443.1"><vh>md:docs/history.md</vh>
<v t="vitalije.20180822170949.2"></v>
</v>
<v t="vitalije.20180822171037.1"><vh>md:docs/index.md</vh>
<v t="vitalije.20180822171037.2"><vh>Welcome to Mini Leo's documentation!</vh></v>
</v>
<v t="vitalije.20180822171107.1"><vh>md:docs/installation.md</vh>
<v t="vitalije.20180822171107.2"><vh>Installation</vh>
<v t="vitalije.20180822171107.3"><vh>Stable release</vh></v>
<v t="vitalije.20180822171107.4"><vh>From sources</vh></v>
</v>
</v>
<v t="vitalije.20180822171113.1"><vh>md:docs/usage.md</vh>
<v t="vitalije.20180822171129.1"><vh>Usage</vh></v>
</v>
<v t="vitalije.20180822171159.1"><vh>md:docs/authors.md</vh>
<v t="vitalije.20180822170856.2"></v>
</v>
<v t="vitalije.20180822182319.1"><vh>md:docs/readme.md</vh>
<v t="vitalije.20180822170827.2"></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="vitalije.20180822151714.2">A minimal version of Leo editor</t>
<t tx="vitalije.20180822164726.1">s = '''AUTHORS.md
CONTRIBUTING.md
HISTORY.md
README.md
index.md
installation.md
usage.md
docs/authors.md
docs/contributing.md
docs/history.md
docs/index.md
docs/installation.md
docs/readme.md
docs/usage.md'''.split('\n')
for x in s:
    p1 = p.insertAsLastChild()
    p1.h = 'md:%s'%x
    p1.b = open(x, 'rt', encoding='utf8').read()

c.redraw()</t>
<t tx="vitalije.20180822170827.1"></t>
<t tx="vitalije.20180822170827.2">[![image](https://img.shields.io/pypi/v/mini_leo.svg)](https://pypi.python.org/pypi/mini_leo)

[![image](https://img.shields.io/travis/vitalije/mini_leo.svg)](https://travis-ci.org/vitalije/mini_leo)

[![Documentation Status](https://readthedocs.org/projects/mini-leo/badge/?version=latest)](https://mini-leo.readthedocs.io/en/latest/?badge=latest)

A minimal version of Leo editor.

-   Free software: MIT license
-   Documentation: &lt;https://mini-leo.readthedocs.io&gt;.
</t>
<t tx="vitalije.20180822170827.3">-   TODO
</t>
<t tx="vitalije.20180822170827.4">This package was created with
[Cookiecutter](https://github.com/audreyr/cookiecutter) and the
[audreyr/cookiecutter-pypackage](https://github.com/audreyr/cookiecutter-pypackage)
project template.
</t>
<t tx="vitalije.20180822170856.1"></t>
<t tx="vitalije.20180822170856.2"></t>
<t tx="vitalije.20180822170856.3">-   Vitalije Milosevic _`&lt;vitalije (at) kviziracija.net&gt;`_
</t>
<t tx="vitalije.20180822170856.4">None yet. Why not be the first?
</t>
<t tx="vitalije.20180822170901.1"></t>
<t tx="vitalije.20180822170949.1"></t>
<t tx="vitalije.20180822170949.2"></t>
<t tx="vitalije.20180822170949.3">-   First release on PyPI.
</t>
<t tx="vitalije.20180822171037.1"></t>
<t tx="vitalije.20180822171037.2">- [Instalation](installation.md)
- [Usage](usage.md)
- [Contributing](contributing.md)
- [Authors](authors.md)
- [History](history.md)
</t>
<t tx="vitalije.20180822171107.1"></t>
<t tx="vitalije.20180822171107.2"></t>
<t tx="vitalije.20180822171107.3">To install Mini Leo, run this command in your terminal:

```shell
$ pip install mini_leo
```

This is the preferred method to install Mini Leo, as it will always
install the most recent stable release.

If you don't have [pip](https://pip.pypa.io) installed, this [Python
installation
guide](http://docs.python-guide.org/en/latest/starting/installation/)
can guide you through the process.
</t>
<t tx="vitalije.20180822171107.4">The sources for Mini Leo can be downloaded from the [Github
repo](https://github.com/vitalije/mini_leo).

You can either clone the public repository:

```shell
$ git clone git://github.com/vitalije/mini_leo
```

Or download the
[tarball](https://github.com/vitalije/mini_leo/tarball/master):

```shell
$ curl  -OL https://github.com/vitalije/mini_leo/tarball/master
```

Once you have a copy of the source, you can install it with:

```shell
$ python setup.py install
```
</t>
<t tx="vitalije.20180822171113.1"></t>
<t tx="vitalije.20180822171129.1">To use Mini Leo in a project:

    import mini_leo</t>
<t tx="vitalije.20180822171159.1"></t>
<t tx="vitalije.20180822171411.1"></t>
<t tx="vitalije.20180822171411.10">Before you submit a pull request, check that it meets these guidelines:

1.  The pull request should include tests.
2.  If the pull request adds functionality, the docs should be updated.
    Put your new functionality into a function with a docstring, and add
    the feature to the list in README.rst.
3.  The pull request should work for Python 2.7, 3.4, 3.5 and 3.6, and
    for PyPy. Check
    &lt;https://travis-ci.org/vitalije/mini_leo/pull_requests&gt; and make
    sure that the tests pass for all supported Python versions.
</t>
<t tx="vitalije.20180822171411.11">To run a subset of tests:

    $ py.test tests.test_mini_leo
</t>
<t tx="vitalije.20180822171411.12">A reminder for the maintainers on how to deploy. Make sure all your
changes are committed (including an entry in HISTORY.rst). Then run:

    $ bumpversion patch # possible: major / minor / patch
    $ git push
    $ git push --tags

Travis will then deploy to PyPI if tests pass.
</t>
<t tx="vitalije.20180822171411.2">Contributions are welcome, and they are greatly appreciated! Every
little bit helps, and credit will always be given.

You can contribute in many ways:
</t>
<t tx="vitalije.20180822171411.3"></t>
<t tx="vitalije.20180822171411.4">Report bugs at &lt;https://github.com/vitalije/mini_leo/issues&gt;.

If you are reporting a bug, please include:

-   Your operating system name and version.
-   Any details about your local setup that might be helpful in
    troubleshooting.
-   Detailed steps to reproduce the bug.
</t>
<t tx="vitalije.20180822171411.5">Look through the GitHub issues for bugs. Anything tagged with "bug"
and "help wanted" is open to whoever wants to implement it.
</t>
<t tx="vitalije.20180822171411.6">Look through the GitHub issues for features. Anything tagged with
"enhancement" and "help wanted" is open to whoever wants to
implement it.
</t>
<t tx="vitalije.20180822171411.7">Mini Leo could always use more documentation, whether as part of the
official Mini Leo docs, in docstrings, or even on the web in blog posts,
articles, and such.
</t>
<t tx="vitalije.20180822171411.8">The best way to send feedback is to file an issue at
&lt;https://github.com/vitalije/mini_leo/issues&gt;.

If you are proposing a feature:

-   Explain in detail how it would work.
-   Keep the scope as narrow as possible, to make it easier to
    implement.
-   Remember that this is a volunteer-driven project, and that
    contributions are welcome :)
</t>
<t tx="vitalije.20180822171411.9">Ready to contribute? Here's how to set up mini_leo for local
development.

1.  Fork the mini_leo repo on GitHub.
2.  Clone your fork locally:

        $ git clone git@github.com:your_name_here/mini_leo.git

3.  Install your local copy into a virtualenv. Assuming you have
    virtualenvwrapper installed, this is how you set up your fork for
    local development:

        $ mkvirtualenv mini_leo
        $ cd mini_leo/
        $ python setup.py develop

4.  Create a branch for local development:

        $ git checkout -b name-of-your-bugfix-or-feature

    Now you can make your changes locally.

5.  When you're done making changes, check that your changes pass
    flake8 and the tests, including testing other Python versions with
    tox:

        $ flake8 mini_leo tests
        $ python setup.py test or py.test
        $ tox

    To get flake8 and tox, just pip install them into your virtualenv.

6.  Commit your changes and push your branch to GitHub:

        $ git add .
        $ git commit -m "Your detailed description of your changes."
        $ git push origin name-of-your-bugfix-or-feature

7.  Submit a pull request through the GitHub website.
</t>
<t tx="vitalije.20180822171443.1"></t>
<t tx="vitalije.20180822171822.1">import subprocess
import re
import shutil
import os
pat = re.compile(r'^(\s*)LEOGNX:(.+)$')
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
@others
px = c.rootPosition()
seen = set()
while px:
    if px.gnx in seen:
        px.moveToNodeAfterTree()
        continue
    seen.add(px.gnx)
    if px.h.startswith('md:'):
        obradi(px)
        px.moveToNodeAfterTree()
    else:
        px.moveToThreadNext()
c.save()
c.fileCommands.save_ref()
save_history()</t>
<t tx="vitalije.20180822171822.2">def hl(p, lev):
    return '#' * (lev) + ' ' + p.h + '\n'</t>
<t tx="vitalije.20180822171822.3">def mdlines(p, lev=0):
    if lev &gt; 0 and not p.b.startswith('#'):
        yield hl(p, lev)
        yield ''
    for line in p.b.splitlines(False):
        m = pat.match(line)
        if m:
            v = c.fileCommands.gnxDict.get(m.group(2))
            if not v:
                g.es('gnx not found:[%s]'%m.group(2))
            else:
                for x in v.b.splitlines(False):
                    yield m.group(1) + x
            continue
        yield line
    yield ''
    for p1 in p.children():
        yield from mdlines(p1, lev + 1)
    yield ''</t>
<t tx="vitalije.20180822171822.4">_CACHE_ = {}
def getf(fname):
    if fname in _CACHE_:
        return _CACHE_[fname]
    if not g.os_path_exists(fname): return ''
    with open(fname, 'rt') as inpt:
        s = inpt.read()
        _CACHE_[fname] = s
        return s
</t>
<t tx="vitalije.20180822171822.5">def putf(fname, cnt):
    if cnt == getf(fname):
        return False
    with open(fname, 'wb') as out:
        out.write(cnt.encode('utf-8'))
        _CACHE_[fname] = cnt
        return True</t>
<t tx="vitalije.20180822171822.6">def obradi(p):
    fname = g.os_path_join(c.openDirectory, p.h[3:].strip())
    s = '\n'.join(mdlines(p))
    putf(fname, s)
    g.es('wrote', fname, len(s), 'bytes')
</t>
<t tx="vitalije.20180822173307.1"></t>
<t tx="vitalije.20180822182319.1"></t>
<t tx="vitalije.20180822183813.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@first #!/usr/bin/env python
@first # -*- coding: utf-8 -*-
"""The setup script."""

@language python
@tabwidth -4

from setuptools import setup, find_packages
import os
cargobin = os.path.expanduser('~/.cargo/bin/cargo')
with open('README.md') as readme_file:
    readme = readme_file.read()

with open('HISTORY.md') as history_file:
    history = history_file.read()

requirements = ['Click&gt;=6.0', 'milksnake']

setup_requirements = ['pytest-runner', 'milksnake']
test_requirements = ['pytest', ]
@others
</t>
<t tx="vitalije.20180822200124.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@first # -*- coding: utf-8 -*-
"""Top-level package for Mini Leo."""
@language python
@tabwidth -4
from mini_leo._native import ffi, lib
def test():
    return lib.a_function_from_rust()

__author__ = """Vitalije Milosevic"""
__email__ = 'vitalije@kviziracija.net'
__version__ = '0.1.0'
</t>
<t tx="vitalije.20180822200508.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@first # -*- coding: utf-8 -*-
"""Console script for mini_leo."""
import sys
import click
from mini_leo import test
@language python
@tabwidth -4
@others
if __name__ == "__main__":
    sys.exit(main())  # pragma: no cover
</t>
<t tx="vitalije.20180822200526.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@first # -*- coding: utf-8 -*-
"""Main module."""
@others
@language python
@tabwidth -4
</t>
<t tx="vitalije.20180822200550.2">@click.command()
def main(args=None):
    """Console script for mini_leo."""
    #click.echo("See click documentation at http://click.pocoo.org/")
    if test() != 42:
        return 1
    return 0
</t>
<t tx="vitalije.20180822200821.1">for v in c.all_unique_nodes():
    if v.h.startswith('@file '):
        v.h = v.h.replace('@file ', '@clean ')
</t>
<t tx="vitalije.20180822204146.1">def build_native(spec):
    # build a native rust library
    build = spec.add_external_build(
        cmd=[cargobin, 'build', '--release'],
        path='rust'
    )

    spec.add_cffi_module(
        module_path='mini_leo._native',
        dylib=lambda: build.find_dylib('mini_leo', in_path='target/release'),
        header_filename=lambda: build.find_header('mini_leo.h', in_path='target'),
        rtld_flags=['NOW', 'NODELETE']
    )

</t>
<t tx="vitalije.20180822204202.1">setup(
    author="Vitalije Milosevic",
    author_email='vitalije@kviziracija.net',
    classifiers=[
        'Development Status :: 2 - Pre-Alpha',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Natural Language :: English',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
    ],
    description="A minimal version of Leo editor.",
    entry_points={
        'console_scripts': [
            'mini_leo=mini_leo.cli:main',
        ],
    },
    install_requires=requirements,
    license="MIT license",
    long_description=readme + '\n\n' + history,
    include_package_data=True,
    keywords='mini_leo',
    name='mini_leo',
    packages=find_packages(include=['mini_leo']),
    setup_requires=setup_requirements,
    test_suite='tests',
    tests_require=test_requirements,
    url='https://github.com/vitalije/mini_leo',
    version='0.1.0',
    zip_safe=False,
    platforms='any',
    milksnake_tasks = [build_native]
)

</t>
<t tx="vitalije.20180822204714.1">@path rust</t>
<t tx="vitalije.20180822204724.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">#[no_mangle]
pub unsafe extern "C" fn a_function_from_rust() -&gt; i32 {
    42
}

</t>
<t tx="vitalije.20180822204947.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">[package]
name = "mini_leo"
version = "0.1.0"
build = "build.rs"

[lib]
name = "mini_leo"
crate-type = ["cdylib"]

[build-dependencies]
cbindgen = "0.5.2"

[dependencies]
clap = "2.33.0"
error-type = "0.1.2"
futures = "0.1.27"
http = "0.1.17"
hyper = "0.12"
mime = "0.3.13"
tokio-fs = "0.1.6"
tokio-io = "0.1.12"
xml-rs = "0.8.0"
#sxd-document = "0.3.2"
#threadpool = "1.7.1"
#net2 = "0.2.33"
#libc = "0.2.58"

[[bin]]
name = "server"
path = "src/bin/server.rs"

[[bin]]
name = "leoxml"
path = "src/bin/leoxml.rs"</t>
<t tx="vitalije.20180822205209.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">extern crate cbindgen;

use std::env;

fn main() {
  let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
  let mut config: cbindgen::Config = Default::default();
  config.language = cbindgen::Language::C;
  cbindgen::generate_with_config(&amp;crate_dir, config)
    .unwrap()
    .write_to_file("target/mini_leo.h");
}

</t>
<t tx="vitalije.20180823001012.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">#!/bin/bash
curl https://sh.rustup.rs -sSf -o /tmp/rustup.sh
sh /tmp/rustup.sh --default-toolchain stable -y
</t>
<t tx="vitalije.20190622132803.7">def save_history():
    if hasattr(c, 'history'):
        with open('/tmp/history-leo.dat', 'wb') as out:
            pickle.dump([c.history, c.snaps], out)</t>
<t tx="vitalije.20190622133345.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Tests for `mini_leo` package."""

import pytest

from click.testing import CliRunner

from mini_leo import cli


@pytest.fixture
def response():
    """Sample pytest fixture.

    See more at: http://doc.pytest.org/en/latest/fixture.html
    """
    # import requests
    # return requests.get('https://github.com/audreyr/cookiecutter-pypackage')


def test_content(response):
    """Sample pytest test function with the pytest fixture as an argument."""
    # from bs4 import BeautifulSoup
    # assert 'GitHub' in BeautifulSoup(response.content).title.string


def test_command_line_interface():
    """Test the CLI."""
    runner = CliRunner()
    result = runner.invoke(cli.main)
    assert result.exit_code == 0
    help_result = runner.invoke(cli.main, ['--help'])
    assert help_result.exit_code == 0
    assert '--help  Show this message and exit.' in help_result.output
</t>
<t tx="vitalije.20190622142851.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
extern crate hyper;
#[macro_use]
extern crate error_type;

extern crate futures;
extern crate clap;
// extern crate tokio_fs;
@others
</t>
<t tx="vitalije.20190622150335.1">fn main() {
  if let Err(e) = run() {
    println!("Error: {}", e.description());
  }
}
</t>
<t tx="vitalije.20190622150400.1">use clap::App;

use futures::{future::Either};

use hyper::{header, Body, Request, Response, Server};
use hyper::rt::Future;
use hyper::service::service_fn;

use hyper::http::status::StatusCode;

use std::{
  error::Error as StdError,
  io,
  net::SocketAddr,
  path::{Path, PathBuf}
};</t>
<t tx="vitalije.20190622150604.1">fn run() -&gt; Result&lt;(), Error&gt; {
  let config = parse_config_from_cmdline()?;
  let Config {addr, root_dir, .. } = config;
  let server = Server::bind(&amp;addr)
    .serve(move || {
      let root_dir = root_dir.clone();
      service_fn(move |req| serve(req, &amp;root_dir.clone()))
    })
    .map_err(|e| {
      println!("There was an error: {}", e);
    });

  hyper::rt::run(server);
  Ok(())
}</t>
<t tx="vitalije.20190622151201.1">#[derive(Clone)]
struct Config {
  addr: SocketAddr,
  root_dir: PathBuf,
  file_name: PathBuf
}</t>
<t tx="vitalije.20190622151325.1">fn parse_config_from_cmdline() -&gt; Result&lt;Config, Error&gt; {
  let matches = App::new("Leo server")
    .version(env!("CARGO_PKG_VERSION"))
    .about("Server that serves Leo outline and its external files")
    .args_from_usage(
      "&lt;FILE&gt; 'leo outline file'
       [ADDR] -a --addr=[ADDR] 'sets the IP:PORT combination (default \"127.0.0.1:4000\")'"
    ).get_matches();
  let addr = matches.value_of("ADDR").unwrap_or("127.0.0.1:4000");
  let fname_arg = matches.value_of("FILE").unwrap();
  let fname_a = std::env::current_dir()?.with_file_name(fname_arg);
  let fname_b = Path::new(fname_arg);

  let root_dir = if fname_b.is_relative() {
    fname_a.parent().unwrap()
  } else {
    fname_b.parent().unwrap()
  };

  let file_name = root_dir.join(fname_b.file_name().unwrap());
  println!("file: [{}]", file_name.display());
  println!("root_dir: [{}]", root_dir.display());
  println!("addr: [{}]", addr);
  Ok(Config {
    addr: addr.parse()?,
    root_dir: PathBuf::from(root_dir),
    file_name: file_name
  })
}
</t>
<t tx="vitalije.20190622153123.1">// The function that returns a future of http responses for each hyper Request
// that is received. Errors are turned into an Error response (404 or 500).
fn serve(
    req: Request&lt;Body&gt;,
    root_dir: &amp;PathBuf,
) -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    let uri_path = req.uri().path();
    if let Some(path) = local_path_for_request(&amp;uri_path, root_dir) {
        Either::A(tokio_fs::file::File::open(path.clone()).then(
            move |open_result| match open_result {
                Ok(file) =&gt; Either::A(read_file(file, path)),
                Err(e) =&gt; Either::B(handle_io_error(e)),
            },
        ))
    } else {
        Either::B(internal_server_error())
    }
}</t>
<t tx="vitalije.20190622153141.1">// Read the file completely and construct a 200 response with that file as
// the body of the response.
fn read_file&lt;'a&gt;(
    file: tokio_fs::File,
    path: PathBuf,
) -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    let buf: Vec&lt;u8&gt; = Vec::new();
    tokio_io::io::read_to_end(file, buf)
        .map_err(Error::Io)
        .and_then(move |(_, buf)| {
            let mime_type = file_path_mime(&amp;path);
            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_LENGTH, buf.len() as u64)
                .header(header::CONTENT_TYPE, mime_type.as_ref())
                .body(Body::from(buf))
                .map_err(Error::from)
        })
}</t>
<t tx="vitalije.20190622153151.1">// Handle the one special io error (file not found) by returning a 404, otherwise
// return a 500
fn handle_io_error(error: io::Error) -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    match error.kind() {
        io::ErrorKind::NotFound =&gt; Either::A(futures::future::result(
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::empty())
                .map_err(Error::from),
        )),
        _ =&gt; Either::B(internal_server_error()),
    }
}</t>
<t tx="vitalije.20190622153201.1">fn file_path_mime(file_path: &amp;Path) -&gt; mime::Mime {
    let mime_type = match file_path.extension().and_then(std::ffi::OsStr::to_str) {
        Some("html") =&gt; mime::TEXT_HTML,
        Some("css") =&gt; mime::TEXT_CSS,
        Some("js") =&gt; mime::TEXT_JAVASCRIPT,
        Some("jpg") =&gt; mime::IMAGE_JPEG,
        Some("png") =&gt; mime::IMAGE_PNG,
        Some("svg") =&gt; mime::IMAGE_SVG,
        Some("wasm") =&gt; "application/wasm".parse::&lt;mime::Mime&gt;().unwrap(),
        _ =&gt; mime::TEXT_PLAIN,
    };
    mime_type
}</t>
<t tx="vitalije.20190622153212.1">fn local_path_for_request(request_path: &amp;str, root_dir: &amp;Path) -&gt; Option&lt;PathBuf&gt; {
    // This is equivalent to checking for hyper::RequestUri::AbsoluteUri
    if !request_path.starts_with("/") {
        return None;
    }
    // Trim off the url parameters starting with '?'
    let end = request_path.find('?').unwrap_or(request_path.len());
    let request_path = &amp;request_path[0..end];

    // Append the requested path to the root directory
    let mut path = root_dir.to_owned();
    if request_path.starts_with('/') {
        path.push(&amp;request_path[1..]);
    } else {
        return None;
    }

    // Maybe turn directory requests into index.html requests
    if request_path.ends_with('/') {
        path.push("index.html");
    }

    Some(path)
}</t>
<t tx="vitalije.20190622153221.1">fn internal_server_error() -&gt; impl Future&lt;Item = Response&lt;Body&gt;, Error = Error&gt; {
    futures::future::result(
        Response::builder()
            .status(StatusCode::INTERNAL_SERVER_ERROR)
            .header(header::CONTENT_LENGTH, 0)
            .body(Body::empty()),
    )
    .map_err(Error::from)
}</t>
<t tx="vitalije.20190622153236.1">// The custom Error type that encapsulates all the possible errors
// that can occur in this crate. This macro defines it and
// automatically creates Display, Error, and From implementations for
// all the variants.
error_type! {
    #[derive(Debug)]
    enum Error {
        Io(io::Error) { },
        HttpError(http::Error) { },
        AddrParse(std::net::AddrParseError) { },
        Std(Box&lt;StdError + Send + Sync&gt;) {
            desc (e) e.description();
        },
        ParseInt(std::num::ParseIntError) { },
    }
}</t>
<t tx="vitalije.20190622191207.1" icons="5d71007d7101285804000000747970657102580400000066696c657103680358620000002f6d656469612f766974616c696a652f686f6d6531312f766974616c696a652f70726f6772616d692f6c656f2d656469746f722f7472756e6b2d6769742f6c656f2f49636f6e732f66696c655f69636f6e732f66696c655f636c65616e322e706e677104580700000072656c506174687105581a00000066696c655f69636f6e732f66696c655f636c65616e322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d580a00000076697375616c49636f6e710e580100000031710f75612e">@language rust
@tabwidth -2
extern crate xml;
extern crate clap;
#[macro_use]
extern crate error_type;
use std::collections::HashMap;
use clap::App;
use xml::reader::{ParserConfig, XmlEvent};

fn parser_config() -&gt; ParserConfig {
  ParserConfig::new()
      .cdata_to_characters(true)
      .whitespace_to_characters(true)
}

use std::{
  error::Error as StdError,
  io,
  io::{Read, BufReader},
  fs::File,
  path::{PathBuf}
};
@others
/*
struct Vnode {
  gnx: String,
  h: String,
  b: String,
  flags: u16
}
*/

fn main() {
  let fname = parse_config_from_cmdline().unwrap();
  _test_parse_leoxml(fname);
  _test_levgnx()
}</t>
<t tx="vitalije.20190622192134.1">fn parse_config_from_cmdline() -&gt; Result&lt;PathBuf, Error&gt; {
  let matches = App::new("Leo server")
    .version(env!("CARGO_PKG_VERSION"))
    .about("Server that serves Leo outline and its external files")
    .args_from_usage(
      "&lt;FILE&gt; 'leo outline file'"
    ).get_matches();
  Ok(PathBuf::from(matches.value_of("FILE").unwrap()))
}
</t>
<t tx="vitalije.20190622192739.1">// The custom Error type that encapsulates all the possible errors
// that can occur in this crate. This macro defines it and
// automatically creates Display, Error, and From implementations for
// all the variants.
error_type! {
    #[derive(Debug)]
    enum Error {
        Io(io::Error) { },
        HttpError(http::Error) { },
        AddrParse(std::net::AddrParseError) { },
        Std(Box&lt;StdError + Send + Sync&gt;) {
            desc (e) e.description();
        },
        ParseInt(std::num::ParseIntError) { },
    }
}</t>
<t tx="vitalije.20190625073241.1">we need:
    - list of known gnxes
    - stack of parent gnxes
    - list of pairs (level, gnx)
    - map gnx -&gt; list of direct child gnxes
    - map gnx -&gt; (h, b)

type 

struct LeoXmlTracker {
    index: Vec&lt;String&gt;,
    ancestors: Vec&lt;String&gt;,
    outline: Vec&lt;u32&gt;
}

Known facts:
    1. when we receive Characters(t) event and last started element is vh,
       then we have h for the last gnx in the outline
    2. when we receive StartElement(v) we should:
        2.1 add its t attribute and level
            to the list of pairs (level, gnx)
        2.2 add its t attribute to children of its parent gnx
        2.3 if it is clone, we should add all its subtree to the outline list
    3. when we receive StartElement(t) clear bodybuf and set bodygnx to be tx attribute
    4. when we receive EndElement(t) update h_b map bodygnx -&gt; b=bodybuf
    </t>
<t tx="vitalije.20190625101104.1">/// converts integer to String in base 64
fn b64str(n:u32) -&gt; String {
  if n == 0 {
    String::from("0")
  } else {
    let mut res = String::new();
    let mut _n = n;
    while _n &gt; 0 {
      res.insert(0, B64DIGITS[(_n &amp; 63) as usize]);
      _n = _n &gt;&gt; 6;
    }
    res
  }
}

/// converts base 64 str to u32
fn b64int(a:&amp;str) -&gt; u32 {
  let mut res = 0_u32;
  for i in a.bytes() {
    let k = B64VALUES[(i &amp; 127) as usize];
    if k == 255 { break }
    res = (res &lt;&lt; 6) + (k as u32);
  }
  res
}</t>
<t tx="vitalije.20190625101129.1">type LevGnx = u32;
pub trait LevGnxUtils {

  /// returns level of this object
  fn level(&amp;self) -&gt; u8;

  /// returns ignx of this object
  fn ignx(&amp;self) -&gt; u32;

  /// increments level of this object
  fn inc(&amp;mut self);

  /// decrements level of this object
  fn dec(&amp;mut self);

  /// changes the level of this object for given delta d
  fn shift(&amp;mut self, d: i8);

  /// sets ignx of this object to given value
  fn set_ignx(&amp;mut self, ignx:u32);

  /// converts this object into ascii representation (4 ascii letters)
  fn to_str(&amp;self) -&gt; String;

  /// creates object from its String representation
  fn from_str(a:&amp;str) -&gt; Self;
}
</t>
<t tx="vitalije.20190625101210.1">fn _test_levgnx() {
  let mut a:LevGnx = 23;
  println!("Ignx {}", a.ignx());
  println!("level {}", a.level());
  a.inc();
  println!("level {}", a.level());
  a.shift(5i8);
  println!("level {}", a.level());
  a.dec();
  println!("level {}", a.level());
  println!("levgnx {}", LevGnx::from_str("01234").to_str());
}</t>
<t tx="vitalije.20190625101337.1">fn _test_parse_leoxml(fname:PathBuf) {
  let f = File::open(&amp;fname).unwrap();
  let mut buf_reader = BufReader::new(f);
  let mut buf = String::new();
  buf_reader.read_to_string(&amp;mut buf).unwrap();
  let config = parser_config();
  let reader = config.create_reader(buf.as_bytes());
  let mut gnx2h:HashMap&lt;String, String&gt; = HashMap::new();
  let mut names:Vec&lt;String&gt; = Vec::new();
  let mut gnxes:Vec&lt;String&gt; = Vec::new();
  let mut txt = String::new();
  let mut lev = 0;
  let s_lev = String::from("...............................................................");
  for xe in reader.into_iter() {
    match xe {
      Ok(XmlEvent::StartElement { name, attributes, ..}) =&gt; {
        let n = name.local_name;
        names.push(n.clone());
        if n == "v" {
          lev += 1;
          gnxes.push(attributes[0].value.clone());
        } else if n == "vnodes" {
          lev=0;
        }
        txt.clear();
      },
      Ok(XmlEvent::Characters(t)) =&gt; txt.push_str(&amp;t),
      Ok(XmlEvent::EndElement{..}) =&gt; {
        let n = names.pop().unwrap();
        if n == "vh" {
          let x = gnxes.pop().unwrap();
          println!("{}{}:{}", s_lev.get(0..lev * 2).unwrap(), txt, x);
          gnx2h.insert(x , txt.clone());
        } else if n == "v" {
          lev -= 1;
        }
      },
      _ =&gt; ()
    }
  }
}</t>
<t tx="vitalije.20190625102142.1">const B64DIGITS:[char;64] = [
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
  'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
  'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c',
  'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
  'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
  't', 'u', 'v', 'w', 'x', 'y', 'z', '~'
];
const B64VALUES:[u8; 128] = [
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
    0u8,   1u8,   2u8,   3u8,   4u8,   5u8,   6u8,   7u8,
    8u8,   9u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8,  10u8,  11u8,  12u8,  13u8,  14u8,  15u8,  16u8,
   17u8,  18u8,  19u8,  20u8,  21u8,  22u8,  23u8,  24u8,
   25u8,  26u8,  27u8,  28u8,  29u8,  30u8,  31u8,  32u8,
   33u8,  34u8,  35u8, 255u8, 255u8, 255u8, 255u8,  36u8,
  255u8,  37u8,  38u8,  39u8,  40u8,  41u8,  42u8,  43u8,
   44u8,  45u8,  46u8,  47u8,  48u8,  49u8,  50u8,  51u8,
   52u8,  53u8,  54u8,  55u8,  56u8,  57u8,  58u8,  59u8,
   60u8,  61u8,  62u8, 255u8, 255u8, 255u8,  63u8, 255u8
];</t>
<t tx="vitalije.20190625102834.1">impl LevGnxUtils for LevGnx {

  fn level(&amp;self) -&gt; u8 {(((*self) &gt;&gt; 18) &amp; 63) as u8}

  fn ignx(&amp;self) -&gt; u32 {(*self) &amp; 0x3ffffu32}

  fn inc(&amp;mut self) {*self += 0x4ffffu32;}

  fn dec(&amp;mut self) {if *self &gt; 0x3ffff {*self -= 0x4ffffu32;}}

  fn shift(&amp;mut self, d: i8) {
    let lev = ((*self &gt;&gt; 18) &amp; 63) as i8 + d;
    *self = (*self &amp; 0x3ffff) | if lev &lt;= 0 { 0 } else { ((lev as u32) &lt;&lt; 18)};
  }

  fn set_ignx(&amp;mut self, ignx:u32) {
    *self = (*self &amp; 0xfc0000) | ignx;
  }

  fn to_str(&amp;self) -&gt; String {
    let mut res = b64str(*self);
    while res.len() &lt; 4 {res.insert(0, '0');}
    res
  }

  fn from_str(a:&amp;str) -&gt; LevGnx {
    b64int(&amp;a[..4]) as LevGnx
  }
}</t>
</tnodes>
</leo_file>
