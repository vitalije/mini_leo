<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="vitalije.20180822151714.2"><vh>Start</vh>
<v t="vitalije.20180822200821.1"><vh>to clean</vh></v>
<v t="vitalije.20180822175121.1"><vh>@edit mkdocs.yml</vh></v>
<v t="vitalije.20180822175420.1"><vh>@edit .gitignore</vh></v>
<v t="vitalije.20180822184227.1"><vh>@edit .travis.yml</vh></v>
<v t="vitalije.20180822184624.1"><vh>@edit MANIFEST.in</vh></v>
<v t="vitalije.20180823001012.1"><vh>@clean rust-installer.sh</vh></v>
<v t="vitalije.20180823103429.1"><vh>@edit setup.cfg</vh></v>
<v t="vitalije.20180823104438.1"><vh>@edit SConstruct</vh></v>
<v t="vitalije.20180823104449.1"><vh>@edit pyproject.toml</vh></v>
<v t="vitalije.20180823132035.1"><vh>@edit requirements_dev.txt</vh></v>
<v t="vitalije.20180822185454.1"><vh>@auto tox.ini</vh></v>
<v t="vitalije.20180822173307.1"><vh>@settings</vh>
<v t="vitalije.20191229164032.1"><vh>@data extract-patterns</vh></v>
<v t="vitalije.20180822171822.1"><vh>@button n-save @key=Ctrl-s</vh>
<v t="vitalije.20180822171822.2"><vh>hl</vh></v>
<v t="vitalije.20180822171822.3"><vh>mdlines</vh></v>
<v t="vitalije.20180822171822.4"><vh>getf</vh></v>
<v t="vitalije.20180822171822.5"><vh>putf</vh></v>
<v t="vitalije.20180822171822.6"><vh>obradi</vh></v>
</v>
</v>
</v>
<v t="vitalije.20180822200124.1"><vh>@clean mini_leo/__init__.py</vh></v>
<v t="vitalije.20180822200508.1"><vh>@clean mini_leo/cli.py</vh>
<v t="vitalije.20180822200550.2"><vh>main (cli.py)</vh></v>
</v>
<v t="vitalije.20180822200526.1"><vh>@clean mini_leo/mini_leo.py</vh></v>
<v t="vitalije.20190622133345.1"><vh>@clean tests/test_mini_leo.py</vh></v>
<v t="vitalije.20180822183813.1"><vh>@clean setup.py</vh>
<v t="vitalije.20191230142308.1"><vh>build_native</vh></v>
</v>
<v t="vitalije.20191231151920.1"><vh>@clean build_wheel.py</vh>
<v t="vitalije.20191231152226.1"><vh>cargo_build</vh></v>
<v t="vitalije.20191231152252.1"><vh>METADATA</vh></v>
<v t="vitalije.20191231152300.1"><vh>WHEEL</vh></v>
<v t="vitalije.20191231153206.1"><vh>getversion</vh></v>
<v t="vitalije.20191231155959.1"><vh>make_wheel</vh></v>
<v t="vitalije.20191231160001.1"><vh>makelinux_wheel</vh></v>
<v t="vitalije.20191231160004.1"><vh>makewin_wheel</vh></v>
<v t="vitalije.20191231160008.1"><vh>makeany_wheel</vh></v>
</v>
<v t="vitalije.20191231162159.1"><vh>@clean appveyor.yml</vh></v>
<v t="vitalije.20180822204714.1"><vh>RUST</vh>
<v t="vitalije.20190625073241.1"><vh>parsing leo xml</vh></v>
<v t="vitalije.20190702085616.1"><vh>rust attick</vh>
<v t="vitalije.20190701152643.1"><vh>main2</vh></v>
<v t="vitalije.20190626141101.1"><vh>ldf_header</vh></v>
</v>
<v t="vitalije.20180822204724.1"><vh>@clean src/lib.rs</vh>
<v t="vitalije.20191215163859.1"><vh>Tree, TreeIterator</vh></v>
<v t="vitalije.20191215164034.1"><vh>TREES</vh></v>
<v t="vitalije.20191215164048.1"><vh>module</vh>
<v t="vitalije.20191215164104.1"><vh>outline_from_str</vh></v>
<v t="vitalije.20191215182759.1"><vh>outline_from_file</vh></v>
<v t="vitalije.20191215183645.1"><vh>outline_from_leo_file</vh></v>
<v t="vitalije.20191215183719.1"><vh>outline_from_leo</vh></v>
<v t="vitalije.20191229172150.1"><vh>load_leo</vh></v>
<v t="vitalije.20200324130742.1"><vh>extract_subtree</vh></v>
<v t="vitalije.20191215164111.1"><vh>node_at</vh></v>
<v t="vitalije.20191215164117.1"><vh>iternodes</vh></v>
<v t="vitalije.20191215194010.1"><vh>drop_tree</vh></v>
<v t="vitalije.20191216171715.1"><vh>at_files</vh></v>
<v t="vitalije.20200324100844.1"><vh>auto_files</vh></v>
<v t="vitalije.20200324100917.1"><vh>clean_files</vh></v>
<v t="vitalije.20200324100938.1"><vh>edit_files</vh></v>
<v t="vitalije.20200324094558.1"><vh>pyatclean_to_str</vh></v>
<v t="vitalije.20200324130524.1"><vh>pyupdate_atclean</vh></v>
<v t="vitalije.20191217044239.1"><vh>tree_len</vh></v>
</v>
</v>
<v t="vitalije.20190702073134.1"><vh>@clean src/model.rs</vh>
<v t="vitalije.20190625101129.1"><vh>LevGnx</vh>
<v t="vitalije.20190702093107.1"><vh>LevGnx implementation</vh></v>
</v>
<v t="vitalije.20190625110116.1"><vh>Outline</vh>
<v t="vitalije.20190702093035.1"><vh>Outline implementation</vh>
<v t="vitalije.20190625121525.1"><vh>has</vh></v>
<v t="vitalije.20190625121531.1"><vh>find</vh></v>
<v t="vitalije.20190625121537.1"><vh>subtree</vh></v>
<v t="vitalije.20190625121544.1"><vh>add_node</vh></v>
<v t="vitalije.20190625122338.1"><vh>parent_index</vh></v>
<v t="vitalije.20190625145720.1"><vh>subtree_size</vh></v>
<v t="vitalije.20190625145812.1"><vh>child_index</vh></v>
</v>
</v>
<v t="vitalije.20190702100427.1"><vh>gnx_index</vh></v>
<v t="vitalije.20190625161035.1"><vh>VData</vh></v>
<v t="vitalije.20200323075415.1"><vh>find_any_file_nodes</vh>
<v t="vitalije.20191216165649.1"><vh>adjust for @path</vh></v>
</v>
<v t="vitalije.20191216165607.1"><vh>find_derived_files</vh></v>
<v t="vitalije.20200323075434.1"><vh>find_clean_files</vh></v>
<v t="vitalije.20200323075457.1"><vh>find_auto_files</vh></v>
<v t="vitalije.20200323075523.1"><vh>find_edit_files</vh></v>
<v t="vitalije.20191229164057.1"><vh>combine_trees</vh></v>
<v t="vitalije.20200323085033.1"><vh>extract_subtree</vh></v>
<v t="vitalije.20200323114517.1"><vh>TreeIterator</vh>
<v t="vitalije.20200323141459.1"><vh>Tree</vh></v>
<v t="vitalije.20200323141509.1"><vh>Tree impl</vh>
<v t="vitalije.20200323141527.1"><vh>new</vh></v>
<v t="vitalije.20200323141530.1"><vh>roots</vh></v>
<v t="vitalije.20200323141537.1"><vh>skip</vh></v>
<v t="vitalije.20200323141541.1"><vh>skip_sections</vh></v>
<v t="vitalije.20200323141554.1"><vh>find_section</vh></v>
<v t="vitalije.20200323141544.1"><vh>others</vh></v>
</v>
</v>
</v>
<v t="vitalije.20190702073410.1"><vh>@clean src/utils.rs</vh>
<v t="vitalije.20190625101104.1"><vh>b64 ints</vh>
<v t="vitalije.20190625102142.1"><vh>constants ...</vh></v>
</v>
<v t="vitalije.20190626141051.1"><vh>rpartition</vh></v>
<v t="vitalije.20200323152529.1"><vh>extract_section_ref</vh></v>
<v t="vitalije.20200323154503.1"><vh>is_directive</vh></v>
<v t="vitalije.20200324091357.1"><vh>is_special</vh></v>
<v t="vitalije.20200324091401.1"><vh>others_index</vh></v>
<v t="vitalije.20200324092152.1"><vh>has_others</vh></v>
<v t="vitalije.20190702085650.1"><vh>tests</vh>
<v t="vitalije.20190630113842.1"><vh>test_rpartition</vh></v>
</v>
</v>
<v t="vitalije.20190625192155.1"><vh>@clean src/parsing.rs</vh>
<v t="vitalije.20190630112527.1"><vh>test</vh>
<v t="vitalije.20190630151934.1"><vh>test_handle_level_stars</vh></v>
</v>
<v t="vitalije.20190630144259.1"><vh>LdfParseState</vh></v>
<v t="vitalije.20190630144250.1"><vh>handle_line</vh>
<v t="vitalije.20190630155031.1"><vh>helpers...</vh>
<v t="vitalije.20190630145512.1"><vh>afterws</vh></v>
<v t="vitalije.20190630145518.1"><vh>tonl</vh></v>
<v t="vitalije.20190630150332.1"><vh>tocolon</vh></v>
<v t="vitalije.20190630153727.1"><vh>tocloseref</vh></v>
<v t="vitalije.20190701152016.1"><vh>to_start_of_bytes</vh></v>
<v t="vitalije.20190630145524.1"><vh>afternl</vh></v>
<v t="vitalije.20190630154640.1"><vh>push_body_line</vh></v>
</v>
<v t="vitalije.20190630154632.1"><vh>handle_leo_line</vh>
<v t="vitalije.20190630152746.1"><vh>check_at_plus_node</vh>
<v t="vitalije.20190630151224.1"><vh>handle_level_stars</vh></v>
</v>
<v t="vitalije.20190630154729.1"><vh>check_at_minus_others</vh></v>
<v t="vitalije.20190630154919.1"><vh>check_at_minus_ref</vh></v>
<v t="vitalije.20190630154613.1"><vh>check_at_plus_ref</vh></v>
<v t="vitalije.20190630154620.1"><vh>check_at_plus_others</vh></v>
<v t="vitalije.20190701193905.1"><vh>check_at_plus_all</vh></v>
<v t="vitalije.20190701194037.1"><vh>check_at_minus_all</vh></v>
<v t="vitalije.20190630192319.1"><vh>check_leo_directives</vh></v>
<v t="vitalije.20190701194331.1"><vh>check_at_verbatim</vh></v>
<v t="vitalije.20190701195722.1"><vh>check_at_raw</vh></v>
<v t="vitalije.20190630192331.1"><vh>check_ignored_sentinels</vh></v>
<v t="vitalije.20190701145231.1"><vh>check_at_first</vh></v>
<v t="vitalije.20190701145239.1"><vh>check_at_plus_at</vh></v>
</v>
</v>
<v t="vitalije.20190630160440.1"><vh>handle_leo_header</vh></v>
<v t="vitalije.20190630155744.1"><vh>ldf_parse</vh></v>
<v t="vitalije.20191215182251.1"><vh>from_derived_file</vh></v>
<v t="vitalije.20191231195159.1"><vh>read_file_as_in_linux</vh></v>
<v t="vitalije.20190702104313.1"><vh>from_derived_file_content</vh></v>
<v t="vitalije.20191215181220.1"><vh>parser_config</vh></v>
<v t="vitalije.20191215181042.1"><vh>from_leo_file</vh></v>
<v t="vitalije.20191215182704.1"><vh>from_leo_content</vh></v>
<v t="vitalije.20200323081335.1"><vh>from_auto_content</vh></v>
<v t="vitalije.20191229171155.1"><vh>load_with_external_files</vh>
<v t="vitalije.20200323075753.1"><vh>load derived files</vh></v>
<v t="vitalije.20200323081110.1"><vh>load auto files</vh></v>
<v t="vitalije.20200323075757.1"><vh>update clean files</vh></v>
<v t="vitalije.20200323080552.1"><vh>update edit files</vh></v>
</v>
</v>
<v t="vitalije.20200323074449.1"><vh>@clean src/atclean.rs</vh>
<v t="vitalije.20200323101936.1"><vh>atclean_to_string</vh>
<v t="vitalije.20200323150457.1"><vh>AtCleanTree iterator</vh></v>
</v>
<v t="vitalije.20200323085359.1"><vh>update_atclean_tree</vh></v>
</v>
<v t="vitalije.20180822205209.1"><vh>@clean build.rs</vh></v>
<v t="vitalije.20180822204947.1"><vh>@clean Cargo.toml</vh></v>
</v>
<v t="vitalije.20180822170827.1"><vh>md:README.md</vh>
<v t="vitalije.20180822170827.2"><vh>Mini Leo</vh>
<v t="vitalije.20180822170827.3"><vh>Features</vh></v>
<v t="vitalije.20180822170827.4"><vh>Credits</vh></v>
</v>
</v>
<v t="vitalije.20180822164726.1"><vh>Doc</vh>
<v t="vitalije.20180822170856.1"><vh>md:AUTHORS.md</vh>
<v t="vitalije.20180822170856.2"><vh>Credits</vh>
<v t="vitalije.20180822170856.3"><vh>Development Lead</vh></v>
<v t="vitalije.20180822170856.4"><vh>Contributors</vh></v>
</v>
</v>
<v t="vitalije.20180822170901.1"><vh>md:CONTRIBUTING.md</vh>
<v t="vitalije.20180822171411.2"><vh>Contributing</vh>
<v t="vitalije.20180822171411.3"><vh>Types of Contributions</vh>
<v t="vitalije.20180822171411.4"><vh>Report Bugs</vh></v>
<v t="vitalije.20180822171411.5"><vh>Fix Bugs</vh></v>
<v t="vitalije.20180822171411.6"><vh>Implement Features</vh></v>
<v t="vitalije.20180822171411.7"><vh>Write Documentation</vh></v>
<v t="vitalije.20180822171411.8"><vh>Submit Feedback</vh></v>
</v>
<v t="vitalije.20180822171411.9"><vh>Get Started!</vh></v>
<v t="vitalije.20180822171411.10"><vh>Pull Request Guidelines</vh></v>
<v t="vitalije.20180822171411.11"><vh>Tips</vh></v>
<v t="vitalije.20180822171411.12"><vh>Deploying</vh></v>
</v>
</v>
<v t="vitalije.20180822170949.1"><vh>md:HISTORY.md</vh>
<v t="vitalije.20180822170949.2"><vh>History</vh>
<v t="vitalije.20180822170949.3"><vh>0.1.0 (2018-08-22)</vh></v>
</v>
</v>
<v t="vitalije.20180822171411.1"><vh>md:docs/contributing.md</vh>
<v t="vitalije.20180822171411.2"></v>
</v>
<v t="vitalije.20180822171443.1"><vh>md:docs/history.md</vh>
<v t="vitalije.20180822170949.2"></v>
</v>
<v t="vitalije.20180822171037.1"><vh>md:docs/index.md</vh>
<v t="vitalije.20180822171037.2"><vh>Welcome to Mini Leo's documentation!</vh></v>
</v>
<v t="vitalije.20180822171107.1"><vh>md:docs/installation.md</vh>
<v t="vitalije.20180822171107.2"><vh>Installation</vh>
<v t="vitalije.20180822171107.3"><vh>Stable release</vh></v>
<v t="vitalije.20180822171107.4"><vh>From sources</vh></v>
</v>
</v>
<v t="vitalije.20180822171113.1"><vh>md:docs/usage.md</vh>
<v t="vitalije.20180822171129.1"><vh>Usage</vh></v>
</v>
<v t="vitalije.20180822171159.1"><vh>md:docs/authors.md</vh>
<v t="vitalije.20180822170856.2"></v>
</v>
<v t="vitalije.20180822182319.1"><vh>md:docs/readme.md</vh>
<v t="vitalije.20180822170827.2"></v>
</v>
</v>
<v t="vitalije.20190702171525.1"><vh>Benchmark results</vh></v>
<v t="vitalije.20200324073138.1"><vh>atclean in python key=Alt-4</vh>
<v t="vitalije.20200324073748.1"><vh>workdata</vh></v>
<v t="vitalije.20200324074019.1"><vh>test_final</vh></v>
<v t="vitalije.20200324074659.1"><vh>atothers_index</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="vitalije.20180822151714.2">A minimal version of Leo editor</t>
<t tx="vitalije.20180822164726.1">s = '''AUTHORS.md
CONTRIBUTING.md
HISTORY.md
README.md
index.md
installation.md
usage.md
docs/authors.md
docs/contributing.md
docs/history.md
docs/index.md
docs/installation.md
docs/readme.md
docs/usage.md'''.split('\n')
for x in s:
    p1 = p.insertAsLastChild()
    p1.h = 'md:%s'%x
    p1.b = open(x, 'rt', encoding='utf8').read()

c.redraw()
</t>
<t tx="vitalije.20180822170827.1"></t>
<t tx="vitalije.20180822170827.2">[![image](https://img.shields.io/pypi/v/mini_leo.svg)](https://pypi.python.org/pypi/mini_leo)

[![image](https://img.shields.io/travis/vitalije/mini_leo.svg)](https://travis-ci.org/vitalije/mini_leo)

[![Documentation Status](https://readthedocs.org/projects/mini-leo/badge/?version=latest)](https://mini-leo.readthedocs.io/en/latest/?badge=latest)

A minimal version of Leo editor.

-   Free software: MIT license
-   Documentation: &lt;https://mini-leo.readthedocs.io&gt;.
</t>
<t tx="vitalije.20180822170827.3">-   TODO
</t>
<t tx="vitalije.20180822170827.4">This package was created with
[Cookiecutter](https://github.com/audreyr/cookiecutter) and the
[audreyr/cookiecutter-pypackage](https://github.com/audreyr/cookiecutter-pypackage)
project template.
</t>
<t tx="vitalije.20180822170856.1"></t>
<t tx="vitalije.20180822170856.2"></t>
<t tx="vitalije.20180822170856.3">-   Vitalije Milosevic _`&lt;vitalije (at) kviziracija.net&gt;`_
</t>
<t tx="vitalije.20180822170856.4">None yet. Why not be the first?
</t>
<t tx="vitalije.20180822170901.1"></t>
<t tx="vitalije.20180822170949.1"></t>
<t tx="vitalije.20180822170949.2"></t>
<t tx="vitalije.20180822170949.3">-   First release on PyPI.
</t>
<t tx="vitalije.20180822171037.1"></t>
<t tx="vitalije.20180822171037.2">- [Instalation](installation.md)
- [Usage](usage.md)
- [Contributing](contributing.md)
- [Authors](authors.md)
- [History](history.md)
</t>
<t tx="vitalije.20180822171107.1"></t>
<t tx="vitalije.20180822171107.2"></t>
<t tx="vitalije.20180822171107.3">To install Mini Leo, run this command in your terminal:

```shell
$ pip install mini_leo
```

This is the preferred method to install Mini Leo, as it will always
install the most recent stable release.

If you don't have [pip](https://pip.pypa.io) installed, this [Python
installation
guide](http://docs.python-guide.org/en/latest/starting/installation/)
can guide you through the process.
</t>
<t tx="vitalije.20180822171107.4">The sources for Mini Leo can be downloaded from the [Github
repo](https://github.com/vitalije/mini_leo).

You can either clone the public repository:

```shell
$ git clone git://github.com/vitalije/mini_leo
```

Or download the
[tarball](https://github.com/vitalije/mini_leo/tarball/master):

```shell
$ curl  -OL https://github.com/vitalije/mini_leo/tarball/master
```

Once you have a copy of the source, you can install it with:

```shell
$ python setup.py install
```
</t>
<t tx="vitalije.20180822171113.1"></t>
<t tx="vitalije.20180822171129.1">To use Mini Leo in a project:

    import mini_leo</t>
<t tx="vitalije.20180822171159.1"></t>
<t tx="vitalije.20180822171411.1"></t>
<t tx="vitalije.20180822171411.10">Before you submit a pull request, check that it meets these guidelines:

1.  The pull request should include tests.
2.  If the pull request adds functionality, the docs should be updated.
    Put your new functionality into a function with a docstring, and add
    the feature to the list in README.rst.
3.  The pull request should work for Python 2.7, 3.4, 3.5 and 3.6, and
    for PyPy. Check
    &lt;https://travis-ci.org/vitalije/mini_leo/pull_requests&gt; and make
    sure that the tests pass for all supported Python versions.
</t>
<t tx="vitalije.20180822171411.11">To run a subset of tests:

    $ py.test tests.test_mini_leo
</t>
<t tx="vitalije.20180822171411.12">A reminder for the maintainers on how to deploy. Make sure all your
changes are committed (including an entry in HISTORY.rst). Then run:

    $ bumpversion patch # possible: major / minor / patch
    $ git push
    $ git push --tags

Travis will then deploy to PyPI if tests pass.
</t>
<t tx="vitalije.20180822171411.2">Contributions are welcome, and they are greatly appreciated! Every
little bit helps, and credit will always be given.

You can contribute in many ways:
</t>
<t tx="vitalije.20180822171411.3"></t>
<t tx="vitalije.20180822171411.4">Report bugs at &lt;https://github.com/vitalije/mini_leo/issues&gt;.

If you are reporting a bug, please include:

-   Your operating system name and version.
-   Any details about your local setup that might be helpful in
    troubleshooting.
-   Detailed steps to reproduce the bug.
</t>
<t tx="vitalije.20180822171411.5">Look through the GitHub issues for bugs. Anything tagged with "bug"
and "help wanted" is open to whoever wants to implement it.
</t>
<t tx="vitalije.20180822171411.6">Look through the GitHub issues for features. Anything tagged with
"enhancement" and "help wanted" is open to whoever wants to
implement it.
</t>
<t tx="vitalije.20180822171411.7">Mini Leo could always use more documentation, whether as part of the
official Mini Leo docs, in docstrings, or even on the web in blog posts,
articles, and such.
</t>
<t tx="vitalije.20180822171411.8">The best way to send feedback is to file an issue at
&lt;https://github.com/vitalije/mini_leo/issues&gt;.

If you are proposing a feature:

-   Explain in detail how it would work.
-   Keep the scope as narrow as possible, to make it easier to
    implement.
-   Remember that this is a volunteer-driven project, and that
    contributions are welcome :)
</t>
<t tx="vitalije.20180822171411.9">Ready to contribute? Here's how to set up mini_leo for local
development.

1.  Fork the mini_leo repo on GitHub.
2.  Clone your fork locally:

        $ git clone git@github.com:your_name_here/mini_leo.git

3.  Install your local copy into a virtualenv. Assuming you have
    virtualenvwrapper installed, this is how you set up your fork for
    local development:

        $ mkvirtualenv mini_leo
        $ cd mini_leo/
        $ python setup.py develop

4.  Create a branch for local development:

        $ git checkout -b name-of-your-bugfix-or-feature

    Now you can make your changes locally.

5.  When you're done making changes, check that your changes pass
    flake8 and the tests, including testing other Python versions with
    tox:

        $ flake8 mini_leo tests
        $ python setup.py test or py.test
        $ tox

    To get flake8 and tox, just pip install them into your virtualenv.

6.  Commit your changes and push your branch to GitHub:

        $ git add .
        $ git commit -m "Your detailed description of your changes."
        $ git push origin name-of-your-bugfix-or-feature

7.  Submit a pull request through the GitHub website.
</t>
<t tx="vitalije.20180822171443.1"></t>
<t tx="vitalije.20180822171822.1">import subprocess
import re
import shutil
import os
pat = re.compile(r'^(\s*)LEOGNX:(.+)$')
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
@others
px = c.rootPosition()
seen = set()
while px:
    if px.gnx in seen:
        px.moveToNodeAfterTree()
        continue
    seen.add(px.gnx)
    if px.h.startswith('md:'):
        obradi(px)
        px.moveToNodeAfterTree()
    else:
        px.moveToThreadNext()
c.frame.tree.clear_visual_icons('save1', {'c': c})
c.save()
c.fileCommands.save_ref()
c.frame.tree.update_appearance('save1', {'c': c})
c.frame.tree.update_appearance_idle('idle', {'c': c})
</t>
<t tx="vitalije.20180822171822.2">def hl(p, lev):
    return '#' * (lev) + ' ' + p.h + '\n'</t>
<t tx="vitalije.20180822171822.3">def mdlines(p, lev=0):
    if lev &gt; 0 and not p.b.startswith('#'):
        yield hl(p, lev)
        yield ''
    for line in p.b.splitlines(False):
        m = pat.match(line)
        if m:
            v = c.fileCommands.gnxDict.get(m.group(2))
            if not v:
                g.es('gnx not found:[%s]'%m.group(2))
            else:
                for x in v.b.splitlines(False):
                    yield m.group(1) + x
            continue
        yield line
    yield ''
    for p1 in p.children():
        yield from mdlines(p1, lev + 1)
    yield ''</t>
<t tx="vitalije.20180822171822.4">_CACHE_ = {}
def getf(fname):
    if fname in _CACHE_:
        return _CACHE_[fname]
    if not g.os_path_exists(fname): return ''
    with open(fname, 'rt') as inpt:
        s = inpt.read()
        _CACHE_[fname] = s
        return s
</t>
<t tx="vitalije.20180822171822.5">def putf(fname, cnt):
    if cnt == getf(fname):
        return False
    with open(fname, 'wb') as out:
        out.write(cnt.encode('utf-8'))
        _CACHE_[fname] = cnt
        return True</t>
<t tx="vitalije.20180822171822.6">def obradi(p):
    fname = g.os_path_join(c.openDirectory, p.h[3:].strip())
    s = '\n'.join(mdlines(p))
    putf(fname, s)
    g.es('wrote', fname, len(s), 'bytes')
</t>
<t tx="vitalije.20180822173307.1"></t>
<t tx="vitalije.20180822182319.1"></t>
<t tx="vitalije.20180822183813.1">#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""The setup script."""


from setuptools import setup, find_packages
import os
cargobin = os.path.expanduser('~/.cargo/bin/cargo')
with open('README.md') as readme_file:
    readme = readme_file.read()

with open('HISTORY.md') as history_file:
    history = history_file.read()

requirements = ['Click&gt;=6.0', 'milksnake']

setup_requirements = ['pytest-runner', 'milksnake']
test_requirements = ['pytest', ]
@others
setup(
    author="Vitalije Milosevic",
    author_email='vitalije@kviziracija.net',
    classifiers=[
        'Development Status :: 2 - Pre-Alpha',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Natural Language :: English',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
    ],
    description="A minimal version of Leo editor.",
    entry_points={
        'console_scripts': [
            'mini_leo=mini_leo.cli:main',
        ],
    },
    install_requires=requirements,
    license="MIT license",
    long_description=readme + '\n\n' + history,
    include_package_data=True,
    keywords='mini_leo',
    name='mini_leo',
    packages=find_packages(include=['mini_leo']),
    setup_requires=setup_requirements,
    test_suite='tests',
    tests_require=test_requirements,
    url='https://github.com/vitalije/mini_leo',
    version='0.1.0',
    zip_safe=False,
    platforms='any',
    milksnake_tasks = [build_native]
)

</t>
<t tx="vitalije.20180822200124.1"># -*- coding: utf-8 -*-
"""Top-level package for Mini Leo."""
from ._minileo import *

__author__ = """Vitalije Milosevic"""
__email__ = 'vitalije@kviziracija.net'
__version__ = '0.1.0'
</t>
<t tx="vitalije.20180822200508.1"># -*- coding: utf-8 -*-
"""Console script for mini_leo."""
import sys
import click
from mini_leo import test
@others
if __name__ == "__main__":
    sys.exit(main())  # pragma: no cover
</t>
<t tx="vitalije.20180822200526.1"># -*- coding: utf-8 -*-
"""Main module."""
</t>
<t tx="vitalije.20180822200550.2">@click.command()
def main(args=None):
    """Console script for mini_leo."""
    #click.echo("See click documentation at http://click.pocoo.org/")
    if test() != 42:
        return 1
    return 0
</t>
<t tx="vitalije.20180822200821.1">for v in c.all_unique_nodes():
    if v.h.startswith('@file '):
        v.h = v.h.replace('@file ', '@clean ')
</t>
<t tx="vitalije.20180822204714.1">@path rust</t>
<t tx="vitalije.20180822204724.1">@language rust
@tabwidth -2
#[path="model.rs"]
mod model;
#[path="utils.rs"]
mod utils;
#[path="parsing.rs"]
mod parsing;
#[path="atclean.rs"]
mod atclean;
use std::collections::HashMap;
use std::sync::{Mutex};
pub use parsing::{ldf_parse,from_derived_file_content, from_derived_file,
                  from_leo_file, from_leo_content, load_with_external_files};
pub use atclean::{atclean_to_string, update_atclean_tree};
pub use utils::{b64int, b64str};
pub use model::{VData, Outline, LevGnx, LevGnxOps, gnx_index,
                find_derived_files, find_edit_files,
                find_auto_files, find_clean_files,
                extract_subtree};
use pyo3::prelude::*;
use pyo3::PyIterProtocol;
use pyo3::{wrap_pyfunction};
use pyo3::type_object::PyTypeObject;
//use xml::reader::{ParserConfig, XmlEvent};
use std::path::{Path};
#[macro_use]
extern crate lazy_static;

#[pyfunction]
pub fn a_function_from_rust() -&gt; PyResult&lt;i32&gt; {
  Ok(42)
}
@others
</t>
<t tx="vitalije.20180822204947.1">[package]
name = "mini_leo"
version = "0.1.0"
build = "build.rs"
edition = "2018"

[lib]
name = "mini_leo"
crate-type = ["cdylib"]

[build-dependencies]
cbindgen = "0.5.2"

[dependencies]
lazy_static = "1.4.0"
#clap = "2.33.0"
#error-type = "0.1.2"
#futures = "0.1.27"
#http = "0.1.17"
#hyper = "0.12"
#mime = "0.3.13"
#tokio-fs = "0.1.6"
#tokio-io = "0.1.12"
#xml-rs = "0.8.0"
quick-xml = "0.17.1"
nom = "5.0.0"
#sxd-document = "0.3.2"
#threadpool = "1.7.1"
#net2 = "0.2.33"
#libc = "0.2.58"
[dependencies.pyo3]
version = "0.8.4"
features = ["extension-module"]
</t>
<t tx="vitalije.20180822205209.1">extern crate cbindgen;

use std::env;

fn main() {
  let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
  let mut config: cbindgen::Config = Default::default();
  config.language = cbindgen::Language::C;
  match cbindgen::generate_with_config(&amp;crate_dir, config) {
    Ok(x) =&gt; x.write_to_file("target/mini_leo.h"),
    Err(e) =&gt; println!("Greska: {}", e)
  }
}

</t>
<t tx="vitalije.20180823001012.1">#!/bin/bash
curl https://sh.rustup.rs -sSf -o /tmp/rustup.sh
sh /tmp/rustup.sh --default-toolchain nightly -y
</t>
<t tx="vitalije.20190622133345.1">#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Tests for `mini_leo` package."""

import pytest

from click.testing import CliRunner

from mini_leo import cli


@pytest.fixture
def response():
    """Sample pytest fixture.

    See more at: http://doc.pytest.org/en/latest/fixture.html
    """
    # import requests
    # return requests.get('https://github.com/audreyr/cookiecutter-pypackage')


def test_content(response):
    """Sample pytest test function with the pytest fixture as an argument."""
    # from bs4 import BeautifulSoup
    # assert 'GitHub' in BeautifulSoup(response.content).title.string


def test_command_line_interface():
    """Test the CLI."""
    runner = CliRunner()
    result = runner.invoke(cli.main)
    assert result.exit_code == 0
    help_result = runner.invoke(cli.main, ['--help'])
    assert help_result.exit_code == 0
    assert '--help  Show this message and exit.' in help_result.output
</t>
<t tx="vitalije.20190625073241.1">we need:
    - list of known gnxes
    - stack of parent gnxes
    - list of pairs (level, gnx)
    - map gnx -&gt; list of direct child gnxes
    - map gnx -&gt; (h, b)

type 

struct LeoXmlTracker {
    index: Vec&lt;String&gt;,
    ancestors: Vec&lt;String&gt;,
    outline: Vec&lt;u32&gt;
}

Known facts:
    1. when we receive Characters(t) event and last started element is vh,
       then we have h for the last gnx in the outline
    2. when we receive StartElement(v) we should:
        2.1 add its t attribute and level
            to the list of pairs (level, gnx)
        2.2 add its t attribute to children of its parent gnx
        2.3 if it is clone, we should add all its subtree to the outline list
    3. when we receive StartElement(t) clear bodybuf and set bodygnx to be tx attribute
    4. when we receive EndElement(t) update h_b map bodygnx -&gt; b=bodybuf
    </t>
<t tx="vitalije.20190625101104.1">/// converts integer to String in base 64
pub fn b64str(n:u32) -&gt; String {
  if n == 0 {
    String::from("0")
  } else {
    let mut res = String::new();
    let mut _n = n;
    while _n &gt; 0 {
      res.insert(0, B64DIGITS[(_n &amp; 63) as usize]);
      _n = _n &gt;&gt; 6;
    }
    res
  }
}

/// converts base 64 str to u32
pub fn b64int(a:&amp;str) -&gt; u32 {
  let mut res = 0_u32;
  for i in a.bytes() {
    let k = B64VALUES[(i &amp; 127) as usize];
    if k == 255 { break }
    res = (res &lt;&lt; 6) + (k as u32);
  }
  res
}</t>
<t tx="vitalije.20190625101129.1">pub type LevGnx = u32;
pub trait LevGnxOps {
  /// returns level of this object
  fn level(&amp;self) -&gt; u8;

  /// returns ignx of this object
  fn ignx(&amp;self) -&gt; u32;

  /// increments level of this object
  fn inc(&amp;mut self);

  /// decrements level of this object
  fn dec(&amp;mut self);

  /// changes the level of this object for given delta d
  fn shift(&amp;mut self, d: i8);

  /// sets ignx of this object to given value
  fn set_ignx(&amp;mut self, ignx:u32);

  /// converts this object into ascii representation (4 ascii letters)
  fn to_str(&amp;self) -&gt; String;

  /// creates object from its String representation
  fn from_str(a:&amp;str) -&gt; LevGnx;

  /// creates object from level and ignx values
  fn make(lev:u8, ignx:u32) -&gt; Self;
}
</t>
<t tx="vitalije.20190625102142.1">const B64DIGITS:[char;64] = [
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
  'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
  'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c',
  'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
  'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
  't', 'u', 'v', 'w', 'x', 'y', 'z', '~'
];
const B64VALUES:[u8; 128] = [
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
    0u8,   1u8,   2u8,   3u8,   4u8,   5u8,   6u8,   7u8,
    8u8,   9u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
  255u8,  10u8,  11u8,  12u8,  13u8,  14u8,  15u8,  16u8,
   17u8,  18u8,  19u8,  20u8,  21u8,  22u8,  23u8,  24u8,
   25u8,  26u8,  27u8,  28u8,  29u8,  30u8,  31u8,  32u8,
   33u8,  34u8,  35u8, 255u8, 255u8, 255u8, 255u8,  36u8,
  255u8,  37u8,  38u8,  39u8,  40u8,  41u8,  42u8,  43u8,
   44u8,  45u8,  46u8,  47u8,  48u8,  49u8,  50u8,  51u8,
   52u8,  53u8,  54u8,  55u8,  56u8,  57u8,  58u8,  59u8,
   60u8,  61u8,  62u8, 255u8, 255u8, 255u8,  63u8, 255u8
];</t>
<t tx="vitalije.20190625110116.1">pub type Outline = Vec&lt;u32&gt;;

pub trait OutlineOps {
  /// returns true if this outline conains a node with given ignx
  fn has(&amp;self, ignx:u32) -&gt; bool;

  /// returns the index of the first node with the given ignx
  /// if the node can't be found returns -1
  fn find(&amp;self, ignx:u32) -&gt; i64;

  /// returns suboutline of the node with the given ignx
  /// if such a node dosen't exist returns an empty outline
  fn subtree(&amp;self, ignx:u32) -&gt; Outline;

  /// appends a node with the given ignx at the given level.
  /// Returns true if the node is clone and its subtree has been added too;
  /// otherwise returns false.
  fn add_node(&amp;mut self, level: u8, ignx: u32) -&gt; bool;

  /// returns the index of the parent node
  fn parent_index(&amp;self, i: usize) -&gt; usize;

  /// returns the size of the subtree starting at given index
  fn subtree_size(&amp;self, i:usize) -&gt; usize;

  /// Given the node located at the given outline index i
  /// this method returns the child index that this node
  /// has in its parent's list of children
  fn child_index(&amp;self, i:usize) -&gt; usize;

}
</t>
<t tx="vitalije.20190625121525.1">/// returns true if this outline conains a node with given ignx
fn has(&amp;self, ignx:u32) -&gt; bool { self.find(ignx) &gt; -1}</t>
<t tx="vitalije.20190625121531.1">/// returns the index of the first node with the given ignx
/// if the node can't be found returns -1
fn find(&amp;self, ignx:u32) -&gt; i64 {
  let mut i = 0i64;
  for x in self {
    if (x &amp; 0x3ffff) == ignx {return i}
    i += 1;
  }
  -1
}</t>
<t tx="vitalije.20190625121537.1">/// returns suboutline of the node with the given ignx
/// if such a node dosen't exist returns an empty outline
fn subtree(&amp;self, ignx:u32) -&gt; Outline {
  let mut res:Outline = Vec::new();
  let j = self.find(ignx);
  if j &lt; 0 { return res }
  let mut i = j as usize;
  let z = self[i];
  let zlev:u8 = z.level();
  let delta:i8 = -(zlev as i8);
  res.push(z.ignx());
  let n = self.len();
  while i + 1 &lt; n {
    i += 1;
    let mut z = self[i];
    if z.level() &lt;= zlev { break };
    z.shift(delta);
    res.push(z);
  }
  res
}</t>
<t tx="vitalije.20190625121544.1">/// appends a node with the given ignx at the given level.
/// Returns true if the node is clone and its subtree has been added too;
/// otherwise returns false.
fn add_node(&amp;mut self, level: u8, ignx: u32) -&gt; bool {
  let max_level:u8 = match self.last() {
    Some(z) =&gt; z.level() + 1,
    None =&gt; 0
  };
  if level &gt; max_level {
    panic!("trying to add a node to level {} when max_level is {}", level, max_level);
  }
  let st = self.subtree(ignx);
  if st.is_empty() {
    self.push(((level as u32) &lt;&lt; 18) | ignx);
    false
  } else {
    for x in st {
      let mut z = x;
      z.shift(level as i8);
      self.push(z);
    }
    true
  }
}</t>
<t tx="vitalije.20190625122338.1">/// returns the index of the parent node
fn parent_index(&amp;self, i: usize) -&gt; usize {
  return match self.get(i) {
    Some(z) =&gt; if z.level() &lt; 2 {
        0
      } else {
        let mut j = i - 1;
        let lev = z.level() - 1;
        while self[j].level() != lev {j -= 1}
        j
      },
    None =&gt; 0
  }
}</t>
<t tx="vitalije.20190625145720.1">/// returns the size of the subtree starting at given index
fn subtree_size(&amp;self, i:usize) -&gt; usize {
  let z:u32 = self[i] &amp; 0xffc_0000;
  for (j, x) in self[i..].iter().enumerate() {
    if z &gt; *x {return j + 1}
  }
  self.len() - i
}</t>
<t tx="vitalije.20190625145812.1">/// Given the node located at the given outline index i
/// this method returns the child index that this node
/// has in its parent's list of children
fn child_index(&amp;self, i:usize) -&gt; usize {
  let pi = self.parent_index(i);
  let mut n:usize = 0;
  let lev = self[i].level();
  for z in &amp;self[pi..i] {
    if z.level() == lev {n += 1}
  }
  n
}
</t>
<t tx="vitalije.20190625161035.1">#[pyclass]
pub struct VData {
  #[pyo3(get, set)]
  pub gnx: String,
  #[pyo3(get, set)]
  pub h: String,
  #[pyo3(get, set)]
  pub b: String,
  #[pyo3(get, set)]
  pub flags: u16
}

#[pymethods]
impl VData {
  #[new]
  fn pynew(obj: &amp;PyRawObject, _gnx:&amp;str) {
    obj.init(VData::new(_gnx));
  }
}
impl VData {
  pub fn new(_gnx:&amp;str) -&gt; VData {
    VData {
      gnx: String::from(_gnx),
      h:String::new(),
      b:String::new(),
      flags:1
    }
  }
  pub fn clone(&amp;self) -&gt; VData {
    VData {
      gnx: self.gnx.clone(),
      h: self.h.clone(),
      b: self.b.clone(),
      flags: self.flags
    }
  }
  pub fn is_expanded(&amp;self) -&gt; bool {self.flags &amp; 1 == 1}
  pub fn section_ref(&amp;self) -&gt; Option&lt;&amp;str&gt; {
    extract_section_ref(self.h.as_str())
  }
}
</t>
<t tx="vitalije.20190625192155.1">@language rust
@tabwidth -2
use crate::model::{VData, Outline, OutlineOps, LevGnx, LevGnxOps, 
             combine_trees, find_derived_files,
             find_clean_files, find_auto_files, find_edit_files};
use crate::atclean::update_atclean_tree;
use quick_xml::Reader as XmlReader;
use quick_xml::events::Event;
use quick_xml::events::attributes::Attributes;

use std::{
  io,
  io::{BufRead, BufReader},
  fs,
  fs::File,
  path::{Path},
  collections::{HashMap}
};
@others
</t>
<t tx="vitalije.20190626141051.1">#[allow(dead_code)]
pub fn rpartition&lt;'a&gt;(input:&amp;'a str, sep:&amp;str) -&gt; (&amp;'a str, &amp;'a str, &amp;'a str) {
  match input.rfind(sep) {
    Some(i) =&gt; {
      let j = i + sep.len();
      (&amp;input[..i], &amp;input[i..j], &amp;input[j..])
    },
    None =&gt; {
      let i = input.len() - 1;
      (&amp;input, &amp;input[i..i], &amp;input[i..i])
    }
  }
}

#[allow(dead_code)]
pub fn partition&lt;'a&gt;(input:&amp;'a str, sep:&amp;str) -&gt; (&amp;'a str, &amp;'a str, &amp;'a str) {
  match input.find(sep) {
    Some(i) =&gt; {
      let j = i + sep.len();
      (&amp;input[..i], &amp;input[i..j], &amp;input[j..])
    },
    None =&gt; {
      let i = input.len() - 1;
      (&amp;input, &amp;input[i..i], &amp;input[i..i])
    }
  }
}</t>
<t tx="vitalije.20190626141101.1">/*
extern crate nom;
use nom::{
  IResult,
  bytes::complete::take_until, //{is_not, is_a, tag, take, take_until, take_while},
  // character::complete::{none_of, one_of, line_ending, char as pchar},
  sequence::pair, //{tuple, pair, preceded},
  //branch::alt,
  // multi::{many_till},
  combinator::map,
  //error::ErrorKind
};

pub fn ldf_header(input:&amp;str) -&gt;  IResult&lt;&amp;str, (&amp;str, &amp;str, &amp;str)&gt; {
  let w1 = take_until("@+leo-ver=5-thin");
  let w2 = pair(w1, take_until("\n"));
  let w3 = map(w2, |(a, b)| {
    let (f, _, st) = rpartition(a, "\n");
    (f, st, &amp;b[16..])
  });
  w3(input)
}
*/</t>
<t tx="vitalije.20190630112527.1">#[cfg(test)]
mod tests {
  @others
}</t>
<t tx="vitalije.20190630113842.1">#[test]
fn test_rpartition() {
  let s = "asepbsepc";
  let res = super::rpartition(s, "sep");
  assert_eq!(res, ("asepb", "sep", "c"));
  let res2 = super::rpartition(s, "d");
  assert_eq!(res2, ("asepbsepc", "", ""));
  let res3 = super::rpartition(s, "a");
  assert_eq!(res3, ("", "a", "sepbsepc"));
}</t>
<t tx="vitalije.20190630144250.1">type NodesBuf = Vec&lt;(usize, usize, usize, usize, usize)&gt;;
type LinesBuf = Vec&lt;(usize, usize, usize, Option&lt;(&amp;'static str, &amp;'static str)&gt;)&gt;;

/// handles a line in derived file
/// if it is ordinary line appends its start, end to the
/// current body
/// else if it is special leo sentinel
/// handles it by changing state or adding a node
fn handle_line&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf){
  let i0 = state.ind;
  let a = afterws(state.buf, i0);

  if state.buf[a..].starts_with(state.st.as_bytes()) &amp;&amp;
    state.buf[(a + state.st.len())] == b'@' {
      // it is a leo sentinel
      state.ind = a + state.st.len() + 1;
      if state.in_all {
        handle_leo_line_in_all(state, nodes, lines)
      } else {
        handle_leo_line(state, a - i0, nodes, lines)
      }
  } else {
    state.ind = afternl(state.buf, a);
    if state.in_doc {
      let a = i0 + state.st.len() + 1;
      let b = state.ind - 1 - state.en.len();
      if a == b - state.indents.last().unwrap() + 1 {
        // empty line in doc part doesn't start with `# `
        // instead it is represented with just `#\n`
        push_body_line(state, a, a+1, Some(("", "\n")), lines);
      } else {
        push_body_line(state, a, b, Some(("", "\n")), lines);
      }
    } else {
      let a = state.ind;
      push_body_line(state, i0, a, None, lines);
    }
  }
}
</t>
<t tx="vitalije.20190630144259.1">struct LdfParseState&lt;'a&gt; {
  ind:usize,
  st:&amp;'a str,
  en:&amp;'a str,
  buf:&amp;'a [u8],
  indents: Vec&lt;usize&gt;,
  mark:usize,
  in_doc:bool,
  path: Vec&lt;usize&gt;,
  first_start: usize,
  first_end: usize,
  last_start: usize,
  // in_raw:bool,
  in_all:bool
}</t>
<t tx="vitalije.20190630145512.1">fn afterws(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; buf[j] == b' ' {
    j += 1;
  }
  j
}</t>
<t tx="vitalije.20190630145518.1">fn tonl(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; buf[j] != b'\n' {
    j += 1;
  }
  j
}</t>
<t tx="vitalije.20190630145524.1">fn afternl(buf:&amp;[u8], i:usize) -&gt; usize { tonl(buf, i) + 1}</t>
<t tx="vitalije.20190630150332.1">fn tocolon(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; buf[j] != b':' {
    j += 1;
  }
  j
}
// fn aftercolon(buf:&amp;[u8], i:usize) -&gt; usize { tocolon(buf, i) + 1 }</t>
<t tx="vitalije.20190630151224.1">fn handle_level_stars(buf:&amp;[u8], i:usize) -&gt; (usize, usize) {
  if buf[i + 1] == b'*' {
    // i - star; i + 1 star; i + 2 space
    (2, i + 3)
  } else if buf[i + 1] == b' ' {
    (1, i + 2)
  } else {
    let mut j = i + 1;
    let mut k = 0;
    while buf[j] != b'*' {
      k = 10 * k + ((buf[j] - b'0') as usize);
      j += 1;
    }
    (k, j + 2)
  }
}</t>
<t tx="vitalije.20190630151934.1">#[test]
fn test_handle_level_stars() {
  let s = b"#@+node:ekr.20050208101229: ** &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (2, 31));
  let s = b"#@+node:ekr.20050208101229: *4* &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (4, 32));
  let s = b"#@+node:ekr.20050208101229: *14* &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (14, 33));
  let s = b"#@+node:ekr.20050208101229: * &lt;&lt; imports  (leoGlobals)";
  assert_eq!(super::handle_level_stars(s, 28), (1, 30))
}</t>
<t tx="vitalije.20190630152746.1">fn check_at_plus_node&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       nodes:&amp;mut NodesBuf,
                       _lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+node:") {
    let a = i0 + 6;
    let b = tocolon(state.buf, a);
    let (lev, c) = handle_level_stars(state.buf, b + 2);
    let d = tonl(state.buf, c);
    nodes.push((lev, a, b, c, d - state.en.len()));
    if let Some(ni) = state.path.last_mut() {
      *ni = nodes.len();
    }
    state.ind = d + 1;
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630153727.1">fn tocloseref(buf:&amp;[u8], i:usize) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; !buf[j..].starts_with(b"&gt;&gt;") {
    j += 1;
  }
  j
}
// fn aftercloseref(buf:&amp;[u8], i:usize) -&gt; usize { tocloseref(buf, i) + 2 }</t>
<t tx="vitalije.20190630154613.1">fn check_at_plus_ref&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+&lt;&lt;") {
    let a = i0 + 1;
    let b = tocloseref(state.buf, a + 2);
    let ni = *(state.path.last().unwrap());
    let wi = *(state.indents.last().unwrap());
    let d = a - 2 - state.st.len();
    let c = d - ws + wi;
    lines.push((ni, c, d, None));
    lines.push((ni, a, b + 2, None));
    state.indents.push(ws);
    state.path.push(0);
    state.ind = afterws(state.buf, afternl(state.buf, state.ind));
    check_at_plus_node(state, nodes, lines);
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630154620.1">fn check_at_plus_others&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+others") {
    let j = afternl(state.buf, i0 + 7);
    let i1 = i0 - state.st.len() - 1 - ws;
    push_body_line(state, i1, i1 + ws, Some(("", "@others")), lines);
    let ni = *state.path.last().unwrap();
    lines.push((ni, i0 + 7, j, None));
    state.indents.push(ws);
    state.path.push(0);
    state.ind = afterws(state.buf, afternl(state.buf, state.ind));
    check_at_plus_node(state, nodes, lines);
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630154632.1">fn handle_leo_line&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf){
  let _ =  check_at_plus_node(state, nodes, lines)
        || check_at_plus_others(state, ws, nodes, lines)
        || check_at_plus_ref(state, ws, nodes, lines)
        || check_at_minus_others(state, nodes, lines)
        || check_at_minus_ref(state, nodes, lines)
        || check_at_plus_at(state, lines)
        || check_at_plus_all(state, ws, nodes, lines)
        || check_at_first(state, lines)
        || check_at_verbatim(state, lines)
        || check_at_raw(state, lines)
        || check_leo_directives(state, ws, lines)
        || check_ignored_sentinels(state)
        || unknown_leo_sentinel(state);
}
fn handle_leo_line_in_all&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf){
   let _ = false
        || check_at_verbatim(state, lines)
        || check_at_plus_node(state, nodes, lines)
        || check_at_minus_all(state, nodes, lines);
}
fn unknown_leo_sentinel(state:&amp;LdfParseState) -&gt; bool {
  let a = state.ind - 2;
  let b = tonl(state.buf, a);
  let _s = std::str::from_utf8(&amp;state.buf[a..b]).unwrap();
  //println!("unknown leo sentinel:[{}] at index:{}", _s, state.ind);
  false //panic!("error");
}
</t>
<t tx="vitalije.20190630154640.1">fn push_body_line&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
  a: usize,
  b: usize,
  e: Option&lt;(&amp;'static str, &amp;'static str)&gt;,
  lines:&amp;mut LinesBuf) {
  if a &gt; b {panic!("push_body_line a &gt; b {} &gt; {}", a, b);}
  let ni = *state.path.last().unwrap();
  let wi = *state.indents.last().unwrap();
  if b - a == 1 {
    lines.push((ni, a, b, e))
  } else {
    if a + wi &gt; b {
      panic!("push_body_line a + wi&gt; b {} + {} &gt; {}", a, wi, b);
    }
    lines.push((ni, a + wi, b, e))
  }
}</t>
<t tx="vitalije.20190630154729.1">fn check_at_minus_others&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       _nodes:&amp;mut NodesBuf,
                       _lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"-others") {
    state.ind = afternl(state.buf, i0 + 7);
    state.path.pop();
    state.indents.pop();
    state.in_doc = false;
    true
  } else {
    false
  }
}
</t>
<t tx="vitalije.20190630154919.1">fn check_at_minus_ref&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       _nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"-&lt;&lt;") {
    let i1 = afternl(state.buf, i0 + 4);
    let i2 = afterws(state.buf, i1);
    let i3 = i2 + state.st.len();
    state.path.pop();
    state.indents.pop();
    let ni = state.path.last().unwrap();
    if state.buf[i2..].starts_with(state.st.as_bytes()) &amp;&amp;
      state.buf[i3..].starts_with(b"@afterref") {
      let i4 = afternl(state.buf, i3 + 9); // after sentinel
      let i5 = afternl(state.buf, i4); // line of text
      lines.push((*ni, i4, i5, None));
      state.ind = i5;
    } else {
      lines.push((*ni, i1 - 1,  i1, None));
      state.ind = i1;
    }
    state.in_doc = false;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190630155031.1"></t>
<t tx="vitalije.20190630155744.1">pub fn ldf_parse&lt;'a&gt;(txt:&amp;'a str) -&gt; (NodesBuf, LinesBuf, usize, usize) {
  let mut nodes:NodesBuf = vec![(0,0,0,0,0)];
  let mut lines:LinesBuf = Vec::new();
  let mut state = handle_leo_header(txt);
  let n = txt.len();
  while state.ind &lt; n {
    if is_at_minus_leo(&amp;mut state) &amp;&amp; !state.in_all{ break }
    handle_line(&amp;mut state, &amp;mut nodes, &amp;mut lines)
  }
  (nodes, lines, state.first_end, state.last_start)
}
fn is_at_minus_leo&lt;'a&gt;(state:&amp;mut LdfParseState) -&gt; bool {
  let a = state.ind;
  let b = state.ind + state.st.len();
  if state.buf[a..].starts_with(state.st.as_bytes()) &amp;&amp; state.buf[b..].starts_with(b"@-leo") {
    state.last_start = afternl(state.buf, b + 5);
    state.ind = state.last_start;
    true
  } else { false}
}
</t>
<t tx="vitalije.20190630160440.1">fn handle_leo_header&lt;'a&gt;(txt:&amp;'a str) -&gt; LdfParseState&lt;'a&gt; {
  let mut state = LdfParseState {
    ind: 0,
    st: "",
    en: "",
    buf: txt.as_bytes(),
    indents: vec![0],
    mark:0,
    in_doc: false,
    path: vec![0],
    first_start:0,
    first_end: 0,
    last_start:txt.len(),
    in_all:false,
    // in_raw:false
  };
  let n = txt.len();
  while state.ind &lt; n {
    if state.buf[state.ind] == b'\n' {
      state.ind += 1;
      state.mark = state.ind;
    } else if state.buf[state.ind..].starts_with(b"@+leo-ver=5-thin") {
      state.first_end = state.mark;
      state.st = &amp;txt[state.mark..state.ind];
      let a = state.ind + 16;
      state.ind = tonl(state.buf, a);
      state.en = &amp;txt[a..state.ind];
      state.ind += 1;
      break;
    } else {
      state.ind += 1;
    }
  }
  state
}</t>
<t tx="vitalije.20190630192319.1">fn check_leo_directives(state:&amp;mut LdfParseState, ws:usize, lines:&amp;mut LinesBuf) -&gt; bool {
  if state.buf[state.ind] == b'@' {
    if state.buf[state.ind..].starts_with(b"@c") || state.buf[state.ind..].starts_with(b"@code") {
      state.in_doc = false;
    }
    let c = tonl(state.buf, state.ind);
    let a = state.ind - ws;
    let b = c - state.en.len();
    push_body_line(state, a, b, Some(("", "\n")), lines);
    state.ind = c + 1;
    true
  } else { false }
}</t>
<t tx="vitalije.20190630192331.1">fn check_ignored_sentinels(state:&amp;mut LdfParseState) -&gt; bool {
  let a = state.buf[state.ind..].starts_with(b"@first")
      ||  state.buf[state.ind..].starts_with(b"@first")
      ||  state.buf[state.ind..].starts_with(b"@first")
      ||  state.buf[state.ind..].starts_with(b"@first");
  if a {
    state.ind = afternl(state.buf, state.ind);
  }
  a
}</t>
<t tx="vitalije.20190701145231.1">fn check_at_first&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;, lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"@first"){
    let i = state.first_start;
    let j = afternl(state.buf, i);
    state.first_start = j;
    lines.push((2, i, j, Some(("@first ", ""))));
    state.ind = afternl(state.buf, i0 + 6);
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190701145239.1">fn check_at_plus_at&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;, lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  let f1 = state.buf[i0..].starts_with(b"+at");
  let f2 = state.buf[i0..].starts_with(b"+doc");
  if f1 || f2 {
    let a = if f1 { i0 + 3} else {i0 + 4};
    let f3 = state.en.len() &gt; 0 &amp;&amp; state.buf[a..].starts_with(state.en.as_bytes());
    let f4 = state.en.len() == 0 &amp;&amp; state.buf[a] == b'\n';
    let ni = *(state.path.last().unwrap());
    if f3 || f4 {
      let opt = if f1 { Some(("@", "")) } else { Some(("@doc", "")) };
      let b = a + state.en.len();
      push_body_line(state, b, b + 1, opt, lines);
      state.ind = b + 1;
    } else {
      let opt = if f1 { Some(("@ ", "\n")) } else { Some(("@doc ", "\n")) };
      let b = tonl(state.buf, a) - state.en.len();
      lines.push((ni, a + 1, b, opt));
      state.ind = b + 1;
    }
    if state.en.len() != 0 {
      let wi = state.indents.last().unwrap();
      let mut a = afternl(state.buf, state.ind) + wi;
      let mut i = a;
      while !state.buf[i..].starts_with(state.en.as_bytes()) {
        if state.buf[i] == b'\n' {
          lines.push((ni, a, i+1, None));
          i += wi + 1;
          a = i;
        } else {
          i += 1;
        }
      }
      state.ind = afternl(state.buf, i);
      state.in_doc = false;
    } else {
      state.in_doc = true;
    }
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190701152016.1">/* fn to_start_of_bytes(buf:&amp;[u8], i:usize, s:&amp;[u8]) -&gt; usize {
  let mut j = i;
  let n = buf.len() - 1;
  while j &lt; n &amp;&amp; !buf[j..].starts_with(s) {
    j += 1;
  }
  j
}
*/</t>
<t tx="vitalije.20190701152643.1">fn main2(data:&amp;[u8], nt:usize) {
  let datastr = std::str::from_utf8(data).unwrap();
  let (nodes, lines, _first_end, _last_start) = ldf_parse(datastr);
  let mut s = String::new();
  for (ni, a, b, e) in lines {
    if ni == nt + 1 {
      match e {
        Some((pref, suf)) =&gt; {
         s.push_str(pref);
          s.push_str(&amp;datastr[a..b]);
          s.push_str(suf);
        },
        None =&gt; s.push_str(&amp;datastr[a..b])
      }
    }
  }
  if let Some((_lev, _a, _b, c, d)) = nodes.get(nt) {
    println!("{}", &amp;datastr[*c..*d]);
    println!("{}", s);
  } else {
    println!("unknown node {}", nt);
  }
}

</t>
<t tx="vitalije.20190701193905.1">fn check_at_plus_all&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       ws:usize,
                       nodes:&amp;mut NodesBuf,
                       lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"+all") {
    let i1 = i0 - state.st.len() - 1 - ws;
    push_body_line(state, i1, i1 + ws, Some(("", "@all\n")), lines);
    state.indents.push(ws);
    state.path.push(0);
    state.ind = afterws(state.buf, afternl(state.buf, state.ind));
    check_at_plus_node(state, nodes, lines);
    state.in_doc = false;
    state.in_all = true;
    true
  } else {
    false
  }
}</t>
<t tx="vitalije.20190701194037.1">fn check_at_minus_all&lt;'a&gt;(state:&amp;mut LdfParseState&lt;'a&gt;,
                       _nodes:&amp;mut NodesBuf,
                       _lines:&amp;mut LinesBuf) -&gt; bool {
  let i0 = state.ind;
  if state.buf[i0..].starts_with(b"-all") {
    state.ind = afternl(state.buf, i0 + 4);
    state.path.pop();
    state.indents.pop();
    state.in_doc = false;
    state.in_all = false;
    true
  } else {
    false
  }
}
</t>
<t tx="vitalije.20190701194331.1">fn check_at_verbatim(state:&amp;mut LdfParseState, lines:&amp;mut LinesBuf) -&gt; bool {
  if state.buf[state.ind..].starts_with(b"verbatim") {
    let a = afternl(state.buf, state.ind + 8);
    let b = afternl(state.buf, a);
    let ni = *(state.path.last().unwrap());
    lines.push((ni, a, b, None));
    state.ind = b;
    true
  } else { false }
}</t>
<t tx="vitalije.20190701195722.1">fn check_at_raw(state:&amp;mut LdfParseState, lines:&amp;mut LinesBuf) -&gt; bool {
  if state.buf[state.ind..].starts_with(b"verbatim") {
    let a = afternl(state.buf, state.ind + 9);
    let b = afternl(state.buf, a);
    let ni = *(state.path.last().unwrap());
    lines.push((ni, a, b, None));
    state.ind = b;
    true
  } else { false }
}</t>
<t tx="vitalije.20190702073134.1">@language rust
@tabwidth -2
#[path="utils.rs"]
mod utils;
use utils::{b64str, b64int, partition, extract_section_ref, has_others};
use std::collections::HashMap;
use pyo3::prelude::*;
use std::path::{ Path};
@others
</t>
<t tx="vitalije.20190702073410.1">@language rust
@tabwidth -2
@others
</t>
<t tx="vitalije.20190702085616.1"></t>
<t tx="vitalije.20190702085650.1">#[cfg(test)]
mod tests {
  @others
}</t>
<t tx="vitalije.20190702093035.1">impl OutlineOps for Outline {
  @others
}
</t>
<t tx="vitalije.20190702093107.1">impl LevGnxOps for LevGnx {

  /// returns level of this object
  fn level(&amp;self) -&gt; u8 {(((*self) &gt;&gt; 18) &amp; 63) as u8}

  /// returns ignx of this object
  fn ignx(&amp;self) -&gt; u32 {(*self) &amp; 0x3ffffu32}

  /// increments level of this object
  fn inc(&amp;mut self) {*self += 0x4ffffu32;}

  /// decrements level of this object
  fn dec(&amp;mut self) {if *self &gt; 0x3ffff {*self -= 0x4ffffu32;}}

  /// changes the level of this object for given delta d
  fn shift(&amp;mut self, d: i8) {
    let lev = ((*self &gt;&gt; 18) &amp; 63) as i8 + d;
    *self = (*self &amp; 0x3ffff) | if lev &lt;= 0 { 0 } else { (lev as u32) &lt;&lt; 18};
  }

  /// sets ignx of this object to given value
  fn set_ignx(&amp;mut self, ignx:u32) {
    *self = (*self &amp; 0xfc0000) | ignx;
  }

  /// converts this object into ascii representation (4 ascii letters)
  fn to_str(&amp;self) -&gt; String {
    let mut res = b64str(*self);
    while res.len() &lt; 4 {res.insert(0, '0');}
    res
  }

  /// creates object from its String representation
  fn from_str(a:&amp;str) -&gt; LevGnx {
    b64int(&amp;a[..4]) as LevGnx
  }

  /// creates object from level and ignx values
  fn make(lev:u8, ignx:u32) -&gt; Self {
    ((lev as u32) &lt;&lt; 18) | (ignx &amp; 0x3ffff)
  }
}</t>
<t tx="vitalije.20190702100427.1">/// returns a map of ignx -&gt; gnx
pub fn gnx_index(nodes:&amp;Vec&lt;VData&gt;) -&gt; HashMap&lt;&amp;str, u32&gt; {
  let mut res = HashMap::new();
  for (i, x) in nodes.iter().enumerate() {
    res.insert(x.gnx.as_str(), i as u32);
  }
  res
}</t>
<t tx="vitalije.20190702104313.1">pub fn from_derived_file_content(content:&amp;str) -&gt; (Outline, Vec&lt;VData&gt;) {
  let mut nodes = Vec::new();
  let mut outline = Vec::new();
  let (vnodes, lines, _, _) = ldf_parse(content);
  let mut i:u32 = 0;
  // TODO: consider changing ldf_parse to skip root node in its output nodes
  // if it skips root node, in the following loop we won't have to check if lev &gt; 0
  // and root node can be inserted in nodes before loop
  for (lev, a, b, c, d) in vnodes {
    if lev &gt; 0 {
      let mut v = VData::new(&amp;content[a..b]);
      v.h.push_str(&amp;content[c..d]);
      nodes.push(v);
      let mut x:LevGnx = i;
      x.shift(lev as i8);
      outline.push(x);
    } else {
      let mut v = VData::new("hidden-root-vnode-gnx");
      v.h.push_str("&lt;hidden root vnode&gt;");
      nodes.push(v)
    }
    i += 1;
  }
  for (i, a, b, op) in lines {
    let v = nodes.get_mut(i-1).unwrap();
    match op {
      Some((pref, suf)) =&gt; {
        v.b.push_str(pref);
        v.b.push_str(&amp;content[a..b]);
        v.b.push_str(suf);
      },
      _ =&gt; v.b.push_str(&amp;content[a..b])
    }
  }
  (outline, nodes)
}</t>
<t tx="vitalije.20190702171525.1">Python 3.7.0 (default, Jun 28 2018, 13:15:42) 
[GCC 7.2.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; def f():
...     with open('leo/test/activeUnitTests.txt', 'r') as inp:
...       s = inp.read()
...       return _minileo.outline_from_str(s)
... 
&gt;&gt;&gt; import _minileo
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; print(timeit.timeit(f, number=100)/100*1000, 'ms')
6.344196610007202 ms</t>
<t tx="vitalije.20191215163859.1">pub struct Tree {
  outline: Outline,
  nodes: Vec&lt;VData&gt;,
}
#[pyclass]
struct TreeIterator {
  tree_id: usize,
  index: usize
}
#[pyproto]
impl PyIterProtocol for TreeIterator {
  fn __iter__(slf:PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Py&lt;TreeIterator&gt;&gt; {
    Ok(slf.into())
  }
  fn __next__(mut slf:PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Option&lt;(u8, VData)&gt;&gt; {
    let m = TREES.lock().unwrap();
    let res = m.get(&amp;slf.tree_id).map(|t|{
      let n = t.outline.len();
      if slf.index &lt; n {
        let levgnx = t.outline[slf.index];
        let i = levgnx.ignx() as usize;
        Some((levgnx.level(), t.nodes[i].clone()))
      } else {
        None
      }
    });
    slf.index += 1;
    match res {
      Some(Some(x)) =&gt; Ok(Some(x)),
      _ =&gt; Ok(None)
    }
  }
}</t>
<t tx="vitalije.20191215164034.1">lazy_static! {
  static ref TREES:Mutex&lt;Box&lt;HashMap&lt;usize,Tree&gt;&gt;&gt; = Mutex::new(Box::new(HashMap::new()));
}
</t>
<t tx="vitalije.20191215164048.1">#[pymodule]
fn _minileo(_py: Python, m:&amp;PyModule) -&gt; PyResult&lt;()&gt; {
  /// creates outline from str
  @others
  m.add_wrapped(wrap_pyfunction!(a_function_from_rust))?;
  m.add("VData", &lt;VData as PyTypeObject&gt;::type_object())?;
  Ok(())
}</t>
<t tx="vitalije.20191215164104.1">#[pyfn(m, "outline_from_str")]
fn outline_from_string(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
  let (outline, nodes) = from_derived_file_content(txt);
  let t = Tree {outline, nodes};
  let mut m = TREES.lock().unwrap();
  let tid = m.len();
  m.insert(tid, t);
  Ok(tid)
}
</t>
<t tx="vitalije.20191215164111.1">#[pyfn(m, "node_at")]
fn node_at(_py: Python, tid:usize, i:usize) -&gt; PyResult&lt;Option&lt;(u8, VData)&gt;&gt; {
  let res = TREES.lock().unwrap().get(&amp;tid).map(|t|{
    let x = t.outline[i];
    let v = t.nodes[x.ignx() as usize].clone();
    (x.level(), v)
  });
  Ok(res)
}
</t>
<t tx="vitalije.20191215164117.1">#[pyfn(m, "iternodes")]
fn iternodes(_py:Python, tid:usize) -&gt; PyResult&lt;TreeIterator&gt; {
  Ok(TreeIterator {tree_id:tid, index:0})
}</t>
<t tx="vitalije.20191215181042.1">pub fn from_leo_file(fname:&amp;Path) -&gt; Result&lt;(Outline, Vec&lt;VData&gt;), io::Error&gt; {
  let s = read_file_as_in_linux(fname)?;
  Ok(from_leo_content(s.as_str()))
}</t>
<t tx="vitalije.20191215181220.1">/*
fn parser_config() -&gt; ParserConfig {
  ParserConfig::new()
      .cdata_to_characters(true)
      .whitespace_to_characters(true)
}
*/</t>
<t tx="vitalije.20191215182251.1">pub fn from_derived_file(fname:&amp;Path) -&gt; Result&lt;(Outline, Vec&lt;VData&gt;), io::Error&gt; {
  let s = read_file_as_in_linux(fname)?;
  Ok(from_derived_file_content(s.as_str()))
}

</t>
<t tx="vitalije.20191215182704.1">pub fn from_leo_content(buf:&amp;str) -&gt; (Outline, Vec&lt;VData&gt;) {
  let mut reader = XmlReader::from_str(buf);
  let mut nodes:Vec&lt;VData&gt; = Vec::new();
  nodes.push(VData::new("hidden-root-vnode-gnx"));
  let mut gnx2i:HashMap&lt;String, usize&gt; = HashMap::new();
  let mut last_gnx = String::new();
  let mut txt = String::new();
  let mut lev = 0u8;
  let mut gnxcount:usize = 1;
  let mut outline:Outline = vec![0u32];
  loop {
    let mut xmlbuf = Vec::new();
    let getattr = |k:&amp;[u8], attrs:Attributes, rr| {
      for x in attrs {
        let a = x.unwrap();
        if a.key == k {
          return a.unescape_and_decode_value(rr).unwrap();
        }
      }
      panic!("missing attribute:{:?}", k);
    };
    match reader.read_event(&amp;mut xmlbuf) {
      Ok(Event::Start(ref e)) =&gt; {
        let n = e.local_name();
        if n == b"v" {
          last_gnx.clear();
          last_gnx.push_str(&amp;getattr(b"t", e.attributes(), &amp;reader));
          let v = VData::new(&amp;last_gnx);
          let ignx = gnx2i.entry(v.gnx.clone()).or_insert(gnxcount);
          lev += 1u8;
          outline.add_node(lev, *ignx as u32);
          nodes.push(v);
          gnxcount += 1;
        } else if n == b"vnodes" {
          lev=0;
        } else if n == b"t" {
          last_gnx.clear();
          last_gnx.push_str(&amp;getattr(b"tx", e.attributes(), &amp;reader));
        }
        txt.clear();
      },
      Ok(Event::Text(e)) =&gt; txt.push_str(&amp;e.unescape_and_decode(&amp;reader).unwrap()),
      Ok(Event::End(ref e)) =&gt; {
        let n = e.local_name();
        if n == b"vh" {
          if let Some(i) = gnx2i.get(&amp;last_gnx) {
            nodes[*i].h.push_str(&amp;txt)
          }
        } else if n == b"v" {
          lev -= 1;
        } else if n == b"t" {
          if let Some(i) = gnx2i.get(&amp;last_gnx) {
            nodes[*i].b.push_str(&amp;txt);
          }
        }
      },
      Ok(Event::Eof) =&gt; break,
      _ =&gt; ()
    }
  }
  (outline, nodes)
}</t>
<t tx="vitalije.20191215182759.1">#[pyfn(m, "outline_from_file")]
fn outline_from_file(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
  match from_derived_file(&amp;Path::new(txt)) {
    Ok((outline, nodes)) =&gt; {
      let t = Tree {outline, nodes};
      let mut m = TREES.lock().unwrap();
      let tid = m.len();
      m.insert(tid, t);
      Ok(tid)
    },
    Err(e) =&gt; Err(pyo3::exceptions::IOError::py_err(e.to_string()))
  }
}</t>
<t tx="vitalije.20191215183645.1">#[pyfn(m, "outline_from_leo_file")]
fn outline_from_leo_file(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
  match from_leo_file(&amp;Path::new(txt)) {
    Ok((outline, nodes)) =&gt; {
      let t = Tree {outline, nodes};
      let mut m = TREES.lock().unwrap();
      let tid = m.len();
      m.insert(tid, t);
      Ok(tid)
    },
    Err(e) =&gt; Err(pyo3::exceptions::IOError::py_err(e.to_string()))
  }
}</t>
<t tx="vitalije.20191215183719.1">#[pyfn(m, "outline_from_leo_str")]
fn outline_from_leo_str(_py: Python, txt:&amp;str) -&gt; PyResult&lt;usize&gt; {
  let (outline, nodes) = from_leo_content(txt);
  let t = Tree {outline, nodes};
  let mut m = TREES.lock().unwrap();
  let tid = m.len();
  m.insert(tid, t);
  Ok(tid)
}
</t>
<t tx="vitalije.20191215194010.1">#[pyfn(m, "drop_tree")]
fn drop_tree(_py:Python, tid:usize) -&gt; PyResult&lt;bool&gt; {
  Ok(TREES.lock().unwrap().remove(&amp;tid).is_some())
}</t>
<t tx="vitalije.20191216165607.1">pub fn find_derived_files(folder:&amp;Path, outline:&amp;Outline, nodes:&amp;Vec&lt;VData&gt;) -&gt; Vec&lt;(String, usize)&gt; {
  find_any_file_nodes(folder, outline, nodes, "@file ")
}
</t>
<t tx="vitalije.20191216165649.1">let np = if v.h.starts_with("@path ") {
  &amp;v.h[6..].trim()
} else if v.b.starts_with("@path ") {
  partition(&amp;v.b[6..], "\n").0.trim()
} else if let Some(i) = v.b.find("\n@path ") {
  partition(&amp;v.b[i+7..], "\n").0.trim()
} else {""};

if lev &lt; stack.len() { stack.drain(lev+1..); }

let mut nf = stack[stack.len() - 1].clone();
if np.len() &gt; 0 {
  for x in np.split(|a|a == '/' || a == '\\') {
    nf.push(x);
  }
}
stack.push(nf);
</t>
<t tx="vitalije.20191216171715.1">#[pyfn(m, "at_files")]
fn at_files(_py:Python, tid:usize, folder:&amp;str) -&gt; PyResult&lt;Vec&lt;(String, usize)&gt;&gt; {
  match TREES.lock().unwrap().get(&amp;tid).map(|t|{
    find_derived_files(&amp;Path::new(folder), &amp;t.outline, &amp;t.nodes)
  }){
    Some(x) =&gt; Ok(x),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}</t>
<t tx="vitalije.20191217044239.1">#[pyfn(m, "tree_len")]
fn tree_len(_py:Python, tid:usize) -&gt; PyResult&lt;usize&gt; {
  match TREES.lock().unwrap().get(&amp;tid).map(|t|{
    t.outline.len() - 1
  }){
    Some(x) =&gt; Ok(x),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}</t>
<t tx="vitalije.20191229164032.1">^\s*(?:pub\s+)?fn\s+(\w+)\s*[(&lt;]
^\s*(?:pub\s+)?struct\s+(\w+)\s*[{]
^\s*(?:pub\s+)?impl\s+(\w+\s+for\s+\w+)\s*[{]
^\s*let\s+(?:mut\s+)?(\w+)\s*=\s*[|][^|]*[|]\s*(?:-&gt;|[{])</t>
<t tx="vitalije.20191229164057.1">pub fn combine_trees(trees:&amp;Vec&lt;(Outline, Vec&lt;VData&gt;)&gt;) -&gt; (Outline, Vec&lt;VData&gt;) {
  let mut catalog:HashMap&lt;&amp;str, (usize, usize)&gt; = HashMap::new();
  for (i, x) in trees.iter().enumerate() {
    let (o, n) = x;
    for y in o.iter() {
      let ignx = y.ignx() as usize;
      let gnx = n[ignx].gnx.as_str();
      catalog.insert(gnx, (i, ignx));
    }
  }
  let vclone = |v:&amp;VData| {
    let gnx = v.gnx.as_str();
    let (i, j) = catalog.get(gnx).unwrap();
    trees[*i].1[*j].clone()
  };
  let (o1, v1) = &amp;trees[0];
  let mut outline = vec![o1[0]];
  let mut vnodes:Vec&lt;VData&gt; = v1.iter().map(vclone).collect();
  let mut real_start = 0;
  let mut i = trees.len();
  let mut ignxes = gnx_index(&amp;v1);
  for (o, n) in trees.iter().rev() {
    i -= 1;
    if i == 0 {
      real_start = outline.len();
      for x in o.iter().skip(1) {
        let gnx = n[x.ignx() as usize].gnx.as_str();
        let ii = ignxes.get(gnx).unwrap();
        outline.add_node(x.level(), *ii);
      }
    } else {
      for v in n.iter() {
        let gnx = v.gnx.as_str();
        if !ignxes.contains_key(gnx) {
          let ii = ignxes.len() as u32;
          ignxes.insert(gnx, ii);
          vnodes.push(vclone(v));
        }
      }
      for x in o {
        let gnx = n[x.ignx() as usize].gnx.as_str();
        let ii = ignxes.get(gnx).unwrap();
        outline.add_node(x.level(), *ii);
      }
    }
  }
  outline.drain(1..real_start);
  (outline, vnodes)
}</t>
<t tx="vitalije.20191229171155.1">pub fn load_with_external_files(fname:&amp;str) -&gt; Result&lt;(Outline, Vec&lt;VData&gt;), io::Error&gt; {
  let pbuf = fs::canonicalize(fname)?;
  let xmlcont = fs::read_to_string(pbuf.as_path())?;
  let mut trees = Vec::new();
  let (outline, mut vnodes) = from_leo_content(xmlcont.as_str());
  let folder = pbuf.parent().unwrap();
  let mut missing_files = Vec::new();
  @others
  trees.insert(0, (outline, vnodes));
  if missing_files.len() &gt; 0 {
    for x in missing_files {
      print!("missing file:{}", &amp;x);
    }
  }
  Ok(combine_trees(&amp;trees))
}</t>
<t tx="vitalije.20191229172150.1">#[pyfn(m, "load_leo")]
fn load_leo(_py: Python, fname:&amp;str) -&gt; PyResult&lt;usize&gt; {
  let tid = match load_with_external_files(fname) {
    Ok((outline, nodes)) =&gt; {
      let t = Tree {outline, nodes};
      let mut m = TREES.lock().unwrap();
      let tid = m.len();
      m.insert(tid, t);
      tid
    },
    Err(e) =&gt; {
      println!("{}", e);
      0
    }
  };
  Ok(tid)
}</t>
<t tx="vitalije.20191230142308.1">def build_native(spec):
    # build a native rust library
    build = spec.add_external_build(
        cmd=[cargobin, 'build', '--lib', '--release'],
        path='rust'
    )

    spec.add_cffi_module(
        module_path='mini_leo._native',
        dylib=lambda: build.find_dylib('mini_leo', in_path='target/release'),
        header_filename=lambda: build.find_header('mini_leo.h', in_path='target'),
        rtld_flags=['NOW', 'NODELETE']
    )</t>
<t tx="vitalije.20191231151920.1">import os
import subprocess
import zipfile
import hashlib
import base64
import sys
from distutils.util import get_platform
PLATFORM = get_platform().replace('-', '_').replace('.', '_')
@others
if __name__ == '__main__':
    cargo_build()
    if not os.path.exists('dist'):
        os.makedirs('dist')
    make_wheel()</t>
<t tx="vitalije.20191231152226.1">def cargo_build():
    proc = subprocess.Popen('cargo build --lib --release',
        cwd='rust', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    [o, e] = proc.communicate()
    print(o.decode('utf8'))
    print(e.decode('utf8'))
    print("cargo finished")
def cargo_build2():
    proc = subprocess.Popen('cargo build --lib',
        cwd='rust', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    [o, e] = proc.communicate()
    print(o.decode('utf8'))
    print(e.decode('utf8'))
    print("cargo finished")</t>
<t tx="vitalije.20191231152252.1">METADATA = b'''
Metadata-Version: 2.1
Name: mini_leo
Version: 0.1.0
Summary: A minimal version of Leo editor.
Home-page: https://github.com/vitalije/mini_leo
Author: Vitalije Milosevic
Author-email: vitalije@kviziracija.net
License: MIT license
Keywords: mini_leo
Platform: any
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
'''.strip()
</t>
<t tx="vitalije.20191231152300.1">WHEEL = b'''Wheel-Version: 1.0
Root-Is-Purelib: false
Tag: py3-none-%s'''%(PLATFORM.encode('utf8'))
</t>
<t tx="vitalije.20191231153206.1">def getversion():
    return METADATA.partition(b'\nVersion:')[2].strip().partition(b'\n')[0].decode('utf8')</t>
<t tx="vitalije.20191231155959.1">def make_wheel():
    if sys.platform == 'linux':
        makelinux_wheel()
    elif sys.platform == 'win32':
        makewin_wheel()
def make_wheel2():
    if sys.platform == 'linux':
        makelinux_wheel2()
    elif sys.platform == 'win32':
        makewin_wheel2()</t>
<t tx="vitalije.20191231160001.1">def makelinux_wheel():
    s = open('rust/target/release/libmini_leo.so', 'rb').read()
    makeany_wheel('mini_leo/_minileo.so', s)
def makelinux_wheel2():
    s = open('rust/target/debug/libmini_leo.so', 'rb').read()
    makeany_wheel('mini_leo/_minileo.so', s)</t>
<t tx="vitalije.20191231160004.1">def makewin_wheel():
    s = open('rust/target/release/mini_leo.dll', 'rb').read()
    makeany_wheel('mini_leo/_minileo.pyd', s)
def makewin_wheel2():
    s = open('rust/target/debug/mini_leo.dll', 'rb').read()
    makeany_wheel('mini_leo/_minileo.pyd', s)</t>
<t tx="vitalije.20191231160008.1">def makeany_wheel(dllname, dllcont):
    ver = getversion()
    zf = zipfile.ZipFile('dist/mini_leo-%s-py3-none-%s.whl'%(ver, PLATFORM), 'w')
    def fline(f, cont):
        return '%s,sha256=%s,%d'%(
                f,
                base64.urlsafe_b64encode(hashlib.sha256(cont).digest()).rstrip(b'=').decode('utf8'),
                len(cont)
            )
    buf = []
    def addf(f, cont):
        buf.append(fline(f, cont))
        zf.writestr(f, cont)
    addf(dllname, dllcont)
    addf('mini_leo/__init__.py', open('mini_leo/__init__.py', 'rb').read())
    dinfo = 'mini_leo-%s.dist-info/'%ver
    addf(dinfo + 'METADATA', METADATA)
    buf.append(dinfo + 'RECORD,,')
    addf(dinfo + 'WHEEL', WHEEL)
    zf.writestr(dinfo + 'RECORD', '\n'.join(buf).encode('utf8'))
    zf.close()</t>
<t tx="vitalije.20191231162159.1">version: 0.1.{build}
image: Visual Studio 2015
shallow_clone: true
clone_depth: 5
environment:
  PYTHON_VERSION: 3.7
  RUSTUP_INSTALLER_ADDRES_X64: https://win.rustup.rs/x86_64
  RUSTUP_INSTALLER_ADDRES_X32: https://win.rustup.rs/i686
cache:
  - '%USERPROFILE%\.cargo\'
  - 'rust\target\'
  - '%USERPROFILE%\.rustup\'
init:
  - set PYTHON=C:\PYTHON37-x64
  - set PATH=%PYTHON%;%PYTHON%\Scripts;%PATH%
install:
  - appveyor-retry appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe
  - rustup-init.exe -y --default-host=x86_64-pc-windows-msvc --profile=minimal --default-toolchain nightly
  - set PATH=%PATH%;%USERPROFILE%\.cargo\bin
platform: x64
build_script:
  - chdir rust
  - '%USERPROFILE%\.cargo\cargo.exe' build --lib --release
  - chdir ..
  - python build_wheel.py
artifacts:
  - path: dist\mini_leo*.whl
</t>
<t tx="vitalije.20191231195159.1">fn read_file_as_in_linux(fname:&amp;Path) -&gt; Result&lt;String, io::Error&gt; {
  let f = File::open(&amp;fname)?;
  let mdata = f.metadata()?;
  let sz = mdata.len() as usize;
  let buf_reader = BufReader::new(f);
  let mut buf = String::with_capacity(sz);
  for line in buf_reader.lines() {
    buf.push_str(line?.as_str());
    buf.push('\n');
  }
  Ok(buf)
}</t>
<t tx="vitalije.20200323074449.1">@language rust
@tabwidth -2
use crate::model::{VData, Outline, LevGnxOps, Tree};
use crate::utils::{extract_section_ref, is_directive, has_others, is_special};
@others
</t>
<t tx="vitalije.20200323075415.1">pub fn find_any_file_nodes(
    folder:&amp;Path,
    outline:&amp;Outline,
    nodes:&amp;Vec&lt;VData&gt;,
    kind:&amp;str)
     -&gt;
     Vec&lt;(String, usize)&gt; {
  let mut stack = vec![folder.to_path_buf()];
  let mut res = Vec::new();
  for (i, x) in outline.iter().enumerate() {
    let lev = x.level() as usize;
    let v = &amp;nodes[x.ignx() as usize];
    @others
    if v.h.starts_with(kind) {
      let fname = v.h[6..].trim();
      let mut p = stack[stack.len() - 1].clone();
      for f in fname.split(|x|x == '\\'  || x == '/') {
        if f == ".." {
          p.pop();
        } else {
          p.push(f);
        }
      }
      res.push((p.to_str().unwrap().to_string(), i));
    }
  }
  res
}</t>
<t tx="vitalije.20200323075434.1">pub fn find_clean_files(folder:&amp;Path, outline:&amp;Outline, nodes:&amp;Vec&lt;VData&gt;) -&gt; Vec&lt;(String, usize)&gt; {
  find_any_file_nodes(folder, outline, nodes, "@clean ")
}
</t>
<t tx="vitalije.20200323075457.1">pub fn find_auto_files(folder:&amp;Path, outline:&amp;Outline, nodes:&amp;Vec&lt;VData&gt;) -&gt; Vec&lt;(String, usize)&gt; {
  find_any_file_nodes(folder, outline, nodes, "@auto ")
}
</t>
<t tx="vitalije.20200323075523.1">pub fn find_edit_files(folder:&amp;Path, outline:&amp;Outline, nodes:&amp;Vec&lt;VData&gt;) -&gt; Vec&lt;(String, usize)&gt; {
  find_any_file_nodes(folder, outline, nodes, "@edit ")
}
</t>
<t tx="vitalije.20200323075753.1">for (f,_) in find_derived_files(folder, &amp;outline, &amp;vnodes) {
  if let Ok(cont) = read_file_as_in_linux(&amp;Path::new(&amp;f)) {
    trees.push(from_derived_file_content(cont.as_str()));
  } else {
    missing_files.push(f);
  }
}</t>
<t tx="vitalije.20200323075757.1">if false {
  let cleanfs = find_clean_files(folder, &amp;outline, &amp;vnodes);
  for (f, ni) in  cleanfs {
    if let Ok(cont) = read_file_as_in_linux(&amp;Path::new(&amp;f)) {
      update_atclean_tree(&amp;outline, &amp;mut vnodes, ni, cont.as_str());
    } else {
      missing_files.push(f);
    }
  }
}</t>
<t tx="vitalije.20200323080552.1">for (f, ni) in find_edit_files(folder, &amp;outline, &amp;vnodes) {
  if let Ok(cont) = read_file_as_in_linux(&amp;Path::new(&amp;f)) {
    for v in vnodes.get_mut(outline[ni as usize].ignx() as usize) {
      v.b.push_str("@nocolor\n");
      v.b.push_str(cont.as_str());
    }
  } else {
    missing_files.push(f);
  }
}
</t>
<t tx="vitalije.20200323081110.1">for (f, ni) in find_auto_files(folder, &amp;outline, &amp;vnodes) {
  if let Ok(cont) = read_file_as_in_linux(&amp;Path::new(&amp;f)) {
    for v in vnodes.get_mut(outline[ni as usize].ignx() as usize) {
      trees.push(from_auto_content(v, cont.as_str()));
    }
  } else {
    missing_files.push(f);
  }
}
</t>
<t tx="vitalije.20200323081335.1">pub fn from_auto_content(v:&amp;VData, cont:&amp;str) -&gt; (Outline, Vec&lt;VData&gt;) {
  let mut v2 = v.clone();
  let mut v1 = VData::new("hidden-root-vnode-gnx");
  v1.h.push_str("&lt;hidden root vnode&gt;");
  v2.b.push_str("@nocolor\n");
  v2.b.push_str(cont);
  let nodes = vec![v1, v2];
  let outline = vec![0, (1 &lt;&lt; 18)|1];
  (outline, nodes)
}</t>
<t tx="vitalije.20200323085033.1">pub fn extract_subtree(
    outline:&amp;Outline,
    nodes:&amp;Vec&lt;VData&gt;,
    ni:usize) -&gt; (Outline, Vec&lt;VData&gt;) {
    let mut o = Vec::new();
    let mut ind:LevGnx = 0;
    let mut vs = Vec::new();
    let zlev = outline[ni].level();
    for lg in &amp;outline[ni..] {
      let lev = lg.level();
      if ind == 0 || lev &gt; zlev {
        let ignx = lg.ignx();
        let v = nodes[ignx as usize].clone();
        o.push(LevGnx::make(lev-zlev, ind));
        vs.push(v);
        ind += 1;
      } else {
        break
      }
    }
    (o, vs)
}</t>
<t tx="vitalije.20200323085359.1">pub fn update_atclean_tree(outline:&amp;Outline, nodes:&amp;mut Vec&lt;VData&gt;, ni:usize, cont:&amp;str) {
  let n = outline.len() + nodes.len() + cont.len()+ni;
  if n &gt; 1 {return}
  let oldtxt = atclean_to_string(outline, nodes, 0);
  let v = nodes.get_mut(0).unwrap();
  if cont.len() == 0 {
    v.b.push_str(cont);
  } else {
    v.b.push_str(oldtxt.as_str());
  }
}
</t>
<t tx="vitalije.20200323101936.1">static SPACES:&amp;'static str = "                                                                                                                                              ";
pub fn atclean_to_string(outline:&amp;Outline, nodes:&amp;Vec&lt;VData&gt;, ni:usize) -&gt; String {
  let mut res = String::new();
  let cleanit = AtCleanTree::new(outline, nodes, ni, 0);
  for (_lev, _v, _a, _b, ind, t) in cleanit {
    if ind &gt; 0 {
      res.push_str(&amp;SPACES[0..ind]);
    }
    res.push_str(t);
    res.push('\n');
  }
  res
}
</t>
<t tx="vitalije.20200323114517.1">@others
impl&lt;'a&gt; Iterator for Tree&lt;'a&gt; {
  type Item = (u8, &amp;'a VData);
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    let i = &amp;mut self.index;
    let o = &amp;self.outline;
    let vs = &amp;self.nodes;
    if *i &lt; o.len() {
      let lev = o[*i].level();
      let v = &amp;vs[o[*i].ignx() as usize];
      *i += 1;
      if !(self.predicat)(lev, v) {
        while *i &lt; o.len() &amp;&amp; o[*i].level() &gt; lev {
          *i += 1;
        }
      }
      Some((lev, v))
    } else {
      None
    }
  }
}</t>
<t tx="vitalije.20200323141459.1">pub struct Tree&lt;'a&gt; {
  outline: &amp;'a Outline,
  nodes: &amp;'a Vec&lt;VData&gt;,
  predicat: fn(u8, &amp;VData) -&gt; bool,
  index: usize
}</t>
<t tx="vitalije.20200323141509.1">#[allow(dead_code)]
impl&lt;'a&gt; Tree&lt;'a&gt; {
  @others
}</t>
<t tx="vitalije.20200323141527.1">pub fn new(outline:&amp;'a Outline, nodes:&amp;'a Vec&lt;VData&gt;) -&gt; Self {
  Tree {
    outline,
    nodes,
    predicat: |_, _| {true},
    index: 0
  }
}</t>
<t tx="vitalije.20200323141530.1">pub fn roots(outline:&amp;'a Outline, nodes:&amp;'a Vec&lt;VData&gt;, predicat:fn(u8, &amp;VData) -&gt; bool) -&gt; Self {
  Tree {
    outline, nodes, predicat, index: 0
  }
}</t>
<t tx="vitalije.20200323141537.1">pub fn skip(&amp;mut self, i:usize) {self.index = i }</t>
<t tx="vitalije.20200323141541.1">pub fn skip_sections(mut self, start:usize) -&gt; impl Iterator&lt;Item=(u8, &amp;'a VData)&gt; {
  self.predicat = |_, v| v.section_ref().is_none();
  self.index = start;
  self.into_iter()
}
pub fn skip_sections_and_nodes_with_others(mut self, start:usize) -&gt; impl Iterator&lt;Item=(u8, &amp;'a VData)&gt; {
  self.predicat = |_, v| {
    v.section_ref().is_none() &amp;&amp; !has_others(v.b.as_str())
  };
  self.index = start;
  self.into_iter()
}</t>
<t tx="vitalije.20200323141544.1">pub fn others(self, start:usize) -&gt; impl Iterator&lt;Item=(u8, &amp;'a VData)&gt; {
  self.skip_sections_and_nodes_with_others(start)
  .filter(|(_, v)|v.section_ref().is_none())
}</t>
<t tx="vitalije.20200323141554.1">pub fn find_section(&amp;self, p:&amp;str, start:usize) -&gt; Option&lt;usize&gt; {
  let o = self.outline;
  let vs = self.nodes;
  let mut i = start;
  let zlev = o[i].level();
  if let Some(x) = vs[o[i].ignx() as usize].section_ref() {
    if x == p {return Some(i)}
  }
  i += 1;
  while i &lt; o.len() &amp;&amp; o[i].level() &gt; zlev {
     if let Some(x) = vs[o[i].ignx() as usize].section_ref() {
      if x == p {return Some(i)}
     }
     i += 1;
  }
  None
}</t>
<t tx="vitalije.20200323150457.1">struct AtCleanTree&lt;'a&gt; {
  o:&amp;'a Outline,
  vs:&amp;'a Vec&lt;VData&gt;,
  ni:usize,
  bi:usize,
  ind:usize,
  children:Vec&lt;AtCleanTree&lt;'a&gt;&gt;
}
impl&lt;'a&gt; AtCleanTree&lt;'a&gt; {
  fn new(o:&amp;'a Outline, vs:&amp;'a Vec&lt;VData&gt;, ni:usize, ind:usize) -&gt; Self {
    AtCleanTree {
      o, vs, ni, bi: 0, ind, children:Vec::new()
    }
  }
}
impl&lt;'a&gt; Iterator for AtCleanTree&lt;'a&gt; {
  type Item = (u8, &amp;'a VData, usize, usize, usize, &amp;'a str);
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    while self.children.len() &gt; 0 {
      let x = self.children[0].next();
      match x {
        Some(x) =&gt; return Some(x),
        None =&gt; {self.children.remove(0);}
      }
    }
    let v = &amp;self.vs[self.o[self.ni].ignx() as usize];
    let b = v.b.as_str();
    let lev = self.o[self.ni].level();
    while self.bi &lt; b.len() {
      let i = self.bi;
      self.bi = i + b[i..].find('\n').unwrap_or(b.len()-i)+1;
      let t = &amp;b[i..self.bi-1];
      if is_directive(t) { continue }
      if !is_special(t) {
        return Some((lev, v, i, self.bi-1, self.ind, t))
      }
      let lt = t.trim_start();
      let ind = t.len() - lt.len();
      if lt.starts_with("@others") {
        // handle others
        let zlev = self.o[self.ni].level();
        let mut skiplevel = 127u8;
        let n = self.o.len();
        let mut nch = 0;
        for i in (self.ni+1)..n {
          let x = self.o[i];
          let lev = x.level();
          if lev &lt;= zlev {break}
          if lev &gt; skiplevel {continue} else {skiplevel = 127u8}
          let v = &amp;self.vs[x.ignx() as usize];
          if extract_section_ref(v.h.as_str()).is_some() {
            skiplevel = lev;
            continue
          }
          self.children.insert(nch, AtCleanTree::new(self.o, self.vs, i, self.ind + ind));
          nch += 1;
          if has_others(&amp;v.b) {
            skiplevel = lev;
          }
        }
        return self.next();
      } else {
        // not others? it must be section reference
        let sname = extract_section_ref(t).unwrap();
        let before = t.find(sname).unwrap();
        self.bi = before + sname.len();
        let ti=Tree::new(self.o, self.vs);
        if let Some(ni) = ti.find_section(sname, self.ni) {
          self.children.insert(0, AtCleanTree::new(self.o, self.vs, ni, ind + self.ind));
        } else {
          break
        }
        if before &gt; ind {
          return Some((lev, v, i, before, self.ind + ind, &amp;t[0..before]))
        } else {
          return self.next()
        }
      }
    }
    None
  }
}</t>
<t tx="vitalije.20200323152529.1">#[allow(dead_code)]
pub fn extract_section_ref(x:&amp;str) -&gt; Option&lt;&amp;str&gt; {
    x.find("&lt;&lt;")
      .map(|i|{
        x.find("&gt;&gt;").map(|j|{(i, j)})
      }).flatten()
      .filter(|(i, j)|i + 3 &lt; *j)
      .map(|(i, j)| &amp;x[i..j+2])
}</t>
<t tx="vitalije.20200323154503.1">#[allow(dead_code)]
pub fn is_directive(t:&amp;str) -&gt; bool {
  t.starts_with("@language") ||
  t.starts_with("@nocolor") ||
  t.starts_with("@killcolor") ||
  t.starts_with("@tabwidth") ||
  t.starts_with("@beautify") ||
  t.starts_with("@nobeautify") ||
  t.starts_with("@killbeautify") ||
  t.starts_with("@nopyflakes") ||
  t.starts_with("@linending") ||
  t.starts_with("@wrap") ||
  t.starts_with("@nowrap") ||
  t.starts_with("@encoding")
}
</t>
<t tx="vitalije.20200324073138.1">import os
@others
c.frame.log.clearTab('Log')
g.es('atothers_index(p)', atothers_index(p.v))
g.es('ok')</t>
<t tx="vitalije.20200324073748.1">def workdata():
    cleans = c.find_h('@clean ')
    for p in cleans:
        fname = p.h.partition(' ')[2].strip()
        if fname.endswith(('.rs', '.toml')):fname = 'rust/'+fname
        assert os.path.exists(fname), fname
        yield p.v, fname</t>
<t tx="vitalije.20200324074019.1">def test_final():
    wd = list(workdata())
    for v, f in wd:
        s1 = open(f, 'r').read()
        s2 = atclean_to_str(v)
        assert s1 == s2, f'\n{repr(s1)}\n{repr(s2)}'</t>
<t tx="vitalije.20200324074659.1">def atothers_index(v):
    b = bytes(v.b, 'utf8')
    if b.lstrip().startswith(b'@others'):
        return 0
    i = b.find(b'@others')
    if i &lt; 0:
        return len(b) + 100
    j = b.rfind(b'\n', 0, i)
    return j + 1</t>
<t tx="vitalije.20200324091357.1">#[allow(dead_code)]
pub fn is_special(t:&amp;str) -&gt; bool {
  t.trim_start().starts_with("@others") || extract_section_ref(t).is_some()
}</t>
<t tx="vitalije.20200324091401.1">#[allow(dead_code)]
pub fn others_index(t:&amp;str) -&gt; usize {
  if t.starts_with("@others") { return 0 }
  for (i, _) in t.match_indices("@others") {
    if let Some(j) = t[0..i].rfind('\n') {
      return j;
    }
  }
  t.len() + 100
}
</t>
<t tx="vitalije.20200324092152.1">#[allow(dead_code)]
pub fn has_others(t:&amp;str) -&gt; bool {
  others_index(t) &lt; t.len()
}</t>
<t tx="vitalije.20200324094558.1">#[pyfn(m, "atclean_to_str")]
fn pyatclean_to_str(_py: Python, tid: usize, ni: usize) -&gt; PyResult&lt;String&gt; {
  match TREES.lock().unwrap().get(&amp;tid).map(|t|{
    atclean_to_string(&amp;t.outline, &amp;t.nodes, ni)
  }) {
    Some(t) =&gt; Ok(t),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}
</t>
<t tx="vitalije.20200324100844.1">#[pyfn(m, "auto_files")]
fn auto_files(_py:Python, tid:usize, folder:&amp;str) -&gt; PyResult&lt;Vec&lt;(String, usize)&gt;&gt; {
  match TREES.lock().unwrap().get(&amp;tid).map(|t|{
    find_auto_files(&amp;Path::new(folder), &amp;t.outline, &amp;t.nodes)
  }){
    Some(x) =&gt; Ok(x),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}</t>
<t tx="vitalije.20200324100917.1">#[pyfn(m, "clean_files")]
fn clean_files(_py:Python, tid:usize, folder:&amp;str) -&gt; PyResult&lt;Vec&lt;(String, usize)&gt;&gt; {
  match TREES.lock().unwrap().get(&amp;tid).map(|t|{
    find_clean_files(&amp;Path::new(folder), &amp;t.outline, &amp;t.nodes)
  }){
    Some(x) =&gt; Ok(x),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}</t>
<t tx="vitalije.20200324100938.1">#[pyfn(m, "edit_files")]
fn edit_files(_py:Python, tid:usize, folder:&amp;str) -&gt; PyResult&lt;Vec&lt;(String, usize)&gt;&gt; {
  match TREES.lock().unwrap().get(&amp;tid).map(|t|{
    find_edit_files(&amp;Path::new(folder), &amp;t.outline, &amp;t.nodes)
  }){
    Some(x) =&gt; Ok(x),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}</t>
<t tx="vitalije.20200324130524.1">#[pyfn(m, "update_atclean")]
fn pyupdate_atclean(_py: Python, tid: usize, ni:usize, cont:&amp;str) -&gt; PyResult&lt;()&gt; {
  match TREES.lock().unwrap().get_mut(&amp;tid).map(|t|{
    update_atclean_tree(&amp;t.outline, &amp;mut t.nodes, ni, cont)
  }) {
    Some(()) =&gt; Ok(()),
    None =&gt; Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  }
}</t>
<t tx="vitalije.20200324130742.1">#[pyfn(m, "extract_subtree")]
fn pyextract_subtree(_py: Python, tid:usize, ni:usize) -&gt; PyResult&lt;usize&gt; {
  let (outline, nodes) = match TREES.lock().unwrap().get(&amp;tid) {
    Some(t) =&gt; extract_subtree(&amp;t.outline, &amp;t.nodes, ni),
    None =&gt; return Err(pyo3::exceptions::ValueError::py_err("unknown tree id"))
  };
  let t = Tree {outline, nodes};
  let mut m = TREES.lock().unwrap();
  let ntid = m.len();
  m.insert(ntid, t);
  Ok(ntid)
}</t>
</tnodes>
</leo_file>
